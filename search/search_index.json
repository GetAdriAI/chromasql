{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ChromaSQL","text":"<p>ChromaSQL is a SQL-inspired domain specific language that maps cleanly to ChromaDB\u2019s vector and metadata query surfaces. It bundles everything you need to parse user-facing queries, validate semantics, inspect execution plans, and run them against a Chroma collection.</p>"},{"location":"#architecture","title":"Architecture","text":"<p>ChromaSQL follows a compiler-style pipeline:</p> <ol> <li>Grammar \u2013 <code>chromasql/grammar.py</code> defines the surface language using Lark.</li> <li>Parser \u2013 <code>chromasql/parser.py</code> turns the parse tree into typed AST nodes.</li> <li>Planner \u2013 <code>chromasql/planner.py</code> converts AST nodes into validated plans.</li> <li>Executor \u2013 <code>chromasql/executor.py</code> runs those plans against ChromaDB.</li> <li>Explain &amp; Analysis \u2013 helpers for tooling, routing, and introspection.</li> </ol> <p>The planner and executor operate on frozen dataclasses (<code>chromasql/ast.py</code> and <code>chromasql/plan.py</code>), making the system easy to test and reason about.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Rich projection, filtering, ordering, pagination, and rerank clauses.</li> <li>Embedding support for inline text, literal vectors, and batches.</li> <li>Optional explain output for debugging query plans.</li> <li>Multi-collection routing primitives and adapters for sharded deployments.</li> <li>100% unit test coverage to keep language changes predictable.</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<p>Pick the path that best suits your workflow. Happy querying! </p> <ul> <li> <p> Using ChromaSQL   Learn the language through the narrative tutorial and clause reference.</p> </li> <li> <p> Using ChromaSQL Python Package   Install the Python SDK, execute plans, and integrate multi-collection routing.</p> </li> <li> <p> Using ChromaSQL with LLMs   Drop this authoring prompt into your assistants so they emit valid queries.</p> </li> <li> <p> Building Extensions   Extend the grammar, planner, executor, and packaging workflow safely.</p> </li> </ul>"},{"location":"building-extensions/","title":"Building Extensions","text":"<p>ChromaSQL is intentionally modular so you can evolve the language and runtime without rewriting the whole stack. This page highlights the recommended workflow, which mirrors the guidelines in <code>CONTRIBUTING.md</code>.</p>"},{"location":"building-extensions/#1-extend-the-ast","title":"1. Extend the AST","text":"<p>Start with <code>chromasql/ast.py</code>. Add new dataclasses or fields that represent the construct you want to support. The AST layer is lightweight and frozen, keeping downstream reasoning simple.</p> <pre><code>@dataclass(frozen=True)\nclass ScoreBoost:\n    field: Field\n    weight: float\n</code></pre>"},{"location":"building-extensions/#2-update-grammar-parser","title":"2. Update Grammar &amp; Parser","text":"<ul> <li>Modify <code>chromasql/grammar.py</code> with the new syntax.</li> <li>Implement transformer hooks in <code>chromasql/parser.py</code> that map tokens to your   AST nodes.</li> <li>Add parser guardrail tests in <code>tests/chromasql/test_internal_errors.py</code>.</li> </ul>"},{"location":"building-extensions/#3-planner-changes","title":"3. Planner Changes","text":"<p>In <code>chromasql/planner.py</code>, translate the AST into plan data structures, enforce semantic rules, and populate <code>QueryPlan</code> fields. For complicated predicates or options, create helper functions with focused unit tests.</p>"},{"location":"building-extensions/#4-executor-updates","title":"4. Executor Updates","text":"<p>Only required if the planner emits new fields the executor needs to honor (e.g., additional include sets or result post-processing). The executor has well-covered helpers in <code>tests/chromasql/test_executor.py</code>.</p>"},{"location":"building-extensions/#5-tests-docs","title":"5. Tests &amp; Docs","text":"<ul> <li>Snapshot tests in <code>tests/chromasql/test_planner.py</code> should cover new grammar.</li> <li>Extend executor, analysis, or multi-collection tests as needed.</li> <li>Update tutorial / docs (<code>TUTORIAL.md</code>, <code>docs/query-language.md</code>, etc.) so the   feature is discoverable.</li> </ul>"},{"location":"building-extensions/#6-packaging-release","title":"6. Packaging &amp; Release","text":"<p>ChromaSQL ships with the same tooling as other packages in the repo:</p> <pre><code>cd chromasql\n./scripts/publish_pypi.sh\n./scripts/sync_public_repo.sh --tag\n</code></pre> <p>Remember to bump the version in <code>pyproject.toml</code> and keep coverage high before publishing.</p>"},{"location":"reference/glossary/","title":"Glossary","text":""},{"location":"reference/glossary/#sharded-deployment","title":"Sharded deployment","text":"<p>A sharded deployment refers to distributing a system across multiple independent instances (shards), where each instance handles a subset of the total data or workload.</p> <p>Benefits:</p> <ul> <li>Scalability: Add more shards as you grow rather than upgrading one massive server</li> <li>Performance: Each shard handles less data, making queries faster</li> <li>Isolation: Issues in one shard don't necessarily affect others</li> </ul>"},{"location":"reference/language-grammar/","title":"ChromaSQL Grammar Specification","text":"<p>ChromaSQL\u2019s grammar is defined in <code>chromasql/grammar.py</code> using Lark. This page summarizes the top-level productions; consult the source file for the authoritative definition.</p>"},{"location":"reference/language-grammar/#start-rule","title":"Start Rule","text":"<pre><code>?start: query\n\n?query: explain? select_stmt \";\"?\n</code></pre> <p><code>EXPLAIN</code> is optional. Semicolons are allowed but not required.</p>"},{"location":"reference/language-grammar/#projection","title":"Projection","text":"<pre><code>projection: \"*\" | projection_item (\",\" projection_item)*\nprojection_item: projection_field projection_alias?\nprojection_field:\n    | \"id\"\n    | \"document\"\n    | \"embedding\"\n    | \"metadata\"\n    | metadata_path\n    | \"distance\"\n</code></pre>"},{"location":"reference/language-grammar/#from-clause","title":"From Clause","text":"<pre><code>select_stmt: \"SELECT\" projection \"FROM\" collection collection_alias? ...\ncollection: IDENT\ncollection_alias: \"AS\" IDENT\n</code></pre>"},{"location":"reference/language-grammar/#embedding-clause","title":"Embedding Clause","text":"<pre><code>embedding_clause: \"USING\" \"EMBEDDING\" (embedding_batch | \"(\" embedding_source \")\")\nembedding_source:\n    | text_embedding\n    | vector_embedding\ntext_embedding: \"TEXT\" string_literal model_override?\nvector_embedding: \"VECTOR\" \"[\" vector_list? \"]\"\nembedding_batch: \"BATCH\" \"(\" embedding_batch_item (\",\" embedding_batch_item)* \")\"\n</code></pre>"},{"location":"reference/language-grammar/#where-clauses","title":"Where Clauses","text":"<pre><code>where_clause: \"WHERE\" predicate\nwhere_document_clause: \"WHERE_DOCUMENT\" document_predicate_expr\n\npredicate:\n    or_expr\n\ndocument_predicate_expr:\n    document_or_expr\ndocument_or_expr:\n    document_and_expr (\"OR\" document_and_expr)*\ndocument_and_expr:\n    document_atom (\"AND\" document_atom)*\ndocument_atom:\n    | \"(\" document_predicate_expr \")\"\n    | \"CONTAINS\" value\n    | \"LIKE\" string_literal\n    | \"document\" \"CONTAINS\" value\n    | \"document\" \"LIKE\" string_literal\n</code></pre> <p>Metadata predicates support:</p> <ul> <li>Comparisons (<code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>)</li> <li><code>IN</code> / <code>NOT IN</code></li> <li><code>BETWEEN</code></li> </ul> <p>Note: <code>LIKE</code> and <code>CONTAINS</code> are only supported for document predicates (via <code>WHERE_DOCUMENT</code>), not for metadata filters. This is a ChromaDB limitation.</p> <p>Both <code>WHERE</code> and <code>WHERE_DOCUMENT</code> support boolean expressions with <code>AND</code> / <code>OR</code> and parentheses for grouping.</p>"},{"location":"reference/language-grammar/#similarity-topk","title":"Similarity &amp; TopK","text":"<pre><code>similarity_clause: \"SIMILARITY\" (\"COSINE\" | \"L2\" | \"IP\")\ntopk_clause: \"TOPK\" INT\n</code></pre>"},{"location":"reference/language-grammar/#ordering-pagination","title":"Ordering &amp; Pagination","text":"<pre><code>order_clause: \"ORDER\" \"BY\" order_item (\",\" order_item)*\norder_item: order_field order_direction?\norder_field: \"distance\" | \"id\" | metadata_path\n\nlimit_clause: \"LIMIT\" INT\noffset_clause: \"OFFSET\" INT\n</code></pre>"},{"location":"reference/language-grammar/#score-threshold-rerank","title":"Score Threshold &amp; Rerank","text":"<pre><code>threshold_clause: \"WITH\" \"SCORE\" \"THRESHOLD\" number_literal\nrerank_clause: \"RERANK\" \"BY\" rerank_strategy\nrerank_strategy: \"MMR\" rerank_params?\nrerank_params: \"(\" rerank_param (\",\" rerank_param)* \")\"\nrerank_param: IDENT \"=\" number_literal\n</code></pre>"},{"location":"reference/language-grammar/#values-literals","title":"Values &amp; Literals","text":"<pre><code>string_literal: STRING\nnumber_literal: SIGNED_NUMBER\nIDENT: /[A-Za-z_][A-Za-z0-9_]*/\n</code></pre> <p>The grammar intentionally omits mutations (INSERT/UPDATE/DELETE) and joins, keeping the DSL squarely focused on read-only retrieval surfaces.</p> <p>Refer to the tutorial and query language reference for examples that exercise each production.</p>"},{"location":"reference/multi-collection-architecture/","title":"Multi-Collection Execution Architecture","text":""},{"location":"reference/multi-collection-architecture/#overview","title":"Overview","text":"<p>ChromaSQL now supports executing queries across multiple ChromaDB collections with intelligent routing based on metadata filters. This implementation is generic and extensible - it doesn't hardcode any specific discriminator field like \"model\", allowing developers to build custom routing strategies for their use cases.</p>"},{"location":"reference/multi-collection-architecture/#what-was-built","title":"What Was Built","text":""},{"location":"reference/multi-collection-architecture/#1-core-abstractions-chromasqlmulti_collectionpy","title":"1. Core Abstractions (<code>chromasql/multi_collection.py</code>)","text":"<p>Two Protocol Interfaces:</p> <ul> <li><code>CollectionRouter</code> - Decides which collections to query based on parsed AST</li> <li>Returns <code>None</code> \u2192 query all collections</li> <li>Returns <code>Sequence[str]</code> \u2192 query specific collections</li> <li> <p>Fully customizable by implementing the protocol</p> </li> <li> <p><code>AsyncCollectionProvider</code> - Abstracts async collection retrieval</p> </li> <li>Works with any async ChromaDB client (HTTP, Cloud, custom)</li> <li>Handles collection caching and connection pooling</li> </ul> <p>Main Function: - <code>execute_multi_collection()</code> - Orchestrates multi-collection execution   - Parses query \u2192 routes to collections \u2192 executes in parallel \u2192 merges results   - Supports both vector and filter-only queries   - Handles partial failures gracefully   - Respects LIMIT/OFFSET/ORDER BY after merging</p>"},{"location":"reference/multi-collection-architecture/#2-pre-built-adapters-chromasqladapterspy","title":"2. Pre-Built Adapters (<code>chromasql/adapters.py</code>)","text":"<p>Three Ready-to-Use Implementations:</p> <ol> <li><code>MetadataFieldRouter</code> - Generic metadata-based routing</li> <li>Extracts values from any metadata field path (e.g., <code>(\"model\",)</code>, <code>(\"tenant\", \"id\")</code>)</li> <li>Uses query config to map values to collections</li> <li> <p>Configurable fallback behavior</p> </li> <li> <p><code>SimpleAsyncClientAdapter</code> - Wraps raw ChromaDB async clients</p> </li> <li>For simpler setups without query config infrastructure</li> </ol>"},{"location":"reference/multi-collection-architecture/#3-comprehensive-tests-testschromasqltest_multi_collectionpy","title":"3. Comprehensive Tests (<code>tests/chromasql/test_multi_collection.py</code>)","text":"<p>11 Test Cases Covering: - Static and dynamic routing - Metadata-based routing (single value, IN lists) - Fallback behavior (query all vs. strict mode) - LIMIT/OFFSET/ORDER BY after merge - Vector and filter-only query modes - Partial collection failure handling - Adapter implementations</p> <p>Test Coverage: 96% overall (1067 statements, 45 miss)</p>"},{"location":"reference/multi-collection-architecture/#4-documentation","title":"4. Documentation","text":"<p>Three Documentation Files: - <code>CONTRIBUTING.md</code> - Updated with multi-collection architecture - <code>EXAMPLES.md</code> - 6 comprehensive usage examples - <code>MULTI_COLLECTION_SUMMARY.md</code> - This file</p>"},{"location":"reference/multi-collection-architecture/#key-design-decisions","title":"Key Design Decisions","text":""},{"location":"reference/multi-collection-architecture/#generic-not-specific","title":"\u2705 Generic, Not Specific","text":"<p>Decision: Don't hardcode \"model\" as the discriminator field</p> <p>Rationale: - Different developers have different metadata structures - Field could be: <code>tenant_id</code>, <code>region</code>, <code>category</code>, <code>model</code>, etc. - Protocol-based design allows unlimited customization</p> <p>Implementation: <pre><code># Generic - works with any field\nrouter = MetadataFieldRouter(config, field_path=(\"model\",))\nrouter = MetadataFieldRouter(config, field_path=(\"tenant_id\",))\nrouter = MetadataFieldRouter(config, field_path=(\"org\", \"region\"))\n</code></pre></p>"},{"location":"reference/multi-collection-architecture/#leverage-existing-analysis-module","title":"\u2705 Leverage Existing Analysis Module","text":"<p>Decision: Use <code>chromasql.analysis.extract_metadata_values()</code> for routing</p> <p>Rationale: - Already existed and was designed for this purpose - Keeps routing logic separate from query execution - Easy to test in isolation</p> <p>Code Reference: chromasql/analysis.py</p>"},{"location":"reference/multi-collection-architecture/#protocol-based-extensibility","title":"\u2705 Protocol-Based Extensibility","text":"<p>Decision: Use Python protocols instead of base classes</p> <p>Rationale: - More Pythonic and flexible - Duck typing enables easy mocking in tests - No inheritance complexity</p> <p>Example: <pre><code>class CollectionRouter(Protocol):\n    def route(self, query: Query) -&gt; Optional[Sequence[str]]:\n        ...\n</code></pre></p>"},{"location":"reference/multi-collection-architecture/#graceful-partial-failures","title":"\u2705 Graceful Partial Failures","text":"<p>Decision: Return results from successful collections even if some fail</p> <p>Rationale: - Common in distributed systems for some nodes to be unavailable - Better to return partial results than fail entirely - Logs errors for monitoring</p> <p>Behavior: - If 35 of 37 collections succeed \u2192 return merged results from 35 - If ALL collections fail \u2192 raise <code>ChromaSQLExecutionError</code></p>"},{"location":"reference/multi-collection-architecture/#result-merging-strategy","title":"\u2705 Result Merging Strategy","text":"<p>Decision: Merge by distance and re-apply ORDER BY/LIMIT/OFFSET</p> <p>Rationale: - Vector queries need global ranking across collections - LIMIT/OFFSET should apply to final merged results, not per-collection - ORDER BY may include multiple fields (e.g., <code>ORDER BY metadata.year DESC, distance ASC</code>)</p> <p>Implementation: chromasql/multi_collection.py</p>"},{"location":"reference/multi-collection-architecture/#integration-with-your-setup","title":"Integration with Your Setup","text":""},{"location":"reference/multi-collection-architecture/#your-current-infrastructure","title":"Your Current Infrastructure","text":"<pre><code>37 collections\n16M total records\nmetadata.model as discriminator\nAsyncMultiCollectionQueryClient already exists\nquery_config.json maps models \u2192 collections\n</code></pre>"},{"location":"reference/multi-collection-architecture/#how-to-use","title":"How to Use","text":"<pre><code>from pathlib import Path\nfrom chromasql.adapters import MetadataFieldRouter\nfrom chromasql.multi_collection import execute_multi_collection\nfrom idxr.query_lib.async_multi_collection_adapter import AsyncMultiCollectionAdapter\nfrom idxr.vectorize_lib.query_client import AsyncMultiCollectionQueryClient\nfrom idxr.vectorize_lib.query_config import load_query_config\n\n# Load config\nconfig = load_query_config(Path(\"output/query_config.json\"))\n\n# Initialize client (your existing code)\nclient = AsyncMultiCollectionQueryClient(\n    config_path=Path(\"output/query_config.json\"),\n    client_type=\"cloud\",\n    cloud_api_key=api_key,\n)\nawait client.connect()\n\n# Create adapters\nadapter = AsyncMultiCollectionAdapter(client)\nrouter = MetadataFieldRouter(\n    query_config=config,\n    field_path=(\"model\",),  # Your discriminator\n    fallback_to_all=True,    # Query all 37 if not specified\n)\n\n# Execute ChromaSQL with routing\nresult = await execute_multi_collection(\n    query_str=\"\"\"\n        SELECT id, distance, document\n        FROM sap_data\n        WHERE metadata.model IN ('Table', 'Field')\n        USING EMBEDDING (TEXT 'financial tables')\n        TOPK 10;\n    \"\"\",\n    router=router,\n    collection_provider=adapter,\n    embed_fn=your_embed_function,\n)\n\n# Router extracted {'Table', 'Field'} from WHERE clause\n# Queried only collections containing those models (e.g., 5 of 37)\n# Results merged and ranked globally by distance\n</code></pre>"},{"location":"reference/multi-collection-architecture/#routing-examples","title":"Routing Examples","text":"<p>Query with model filter \u2192 targeted routing: <pre><code>SELECT * FROM demo\nWHERE metadata.model = 'Table'\nUSING EMBEDDING (TEXT 'query')\n-- Queries only collections containing 'Table'\n</code></pre></p> <p>Query without model filter \u2192 all collections: <pre><code>SELECT * FROM demo\nWHERE metadata.year &gt; 2020\nUSING EMBEDDING (TEXT 'query')\n-- Queries all 37 collections (model not constrained)\n</code></pre></p> <p>Filter-only query \u2192 works too: <pre><code>SELECT * FROM demo\nWHERE metadata.model = 'Field'\n  AND metadata.status = 'active'\n-- No USING EMBEDDING = filter-only mode\n-- Still routes based on metadata.model\n</code></pre></p>"},{"location":"reference/multi-collection-architecture/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"reference/multi-collection-architecture/#parallel-execution","title":"Parallel Execution","text":"<ul> <li>All collections queried in parallel using <code>asyncio.gather()</code></li> <li>No sequential bottlenecks</li> </ul>"},{"location":"reference/multi-collection-architecture/#network-efficiency","title":"Network Efficiency","text":"<ul> <li>Only queries collections that contain the filtered models</li> <li>Example: Filter on 2 models \u2192 query 5 collections (not all 37)</li> </ul>"},{"location":"reference/multi-collection-architecture/#result-merging","title":"Result Merging","text":"<ul> <li>In-memory merge after collection queries complete</li> <li>Complexity: O(n log n) where n = total results from all collections</li> <li>For TOPK 10 across 5 collections \u2192 sorts ~50 items, returns top 10</li> </ul>"},{"location":"reference/multi-collection-architecture/#recommended-patterns","title":"Recommended Patterns","text":"<ol> <li> <p>Use specific model filters when possible: <pre><code>WHERE metadata.model IN ('Table', 'Field')  -- Good: queries 5 collections\nWHERE metadata.status = 'active'             -- Queries all 37 collections\n</code></pre></p> </li> <li> <p>Fetch more candidates per collection for better recall: <pre><code>result = await execute_multi_collection(\n    query_str=...,\n    n_results_per_collection=50,  # Fetch 50 from each collection\n    # Final result still respects TOPK/LIMIT in query\n)\n</code></pre></p> </li> <li> <p>Monitor routing decisions: <pre><code>query = parse(sql)\ncollections = router.route(query)\nlogger.info(f\"Querying {len(collections) if collections else 'all'} collection(s)\")\n</code></pre></p> </li> </ol>"},{"location":"reference/multi-collection-architecture/#testing-coverage","title":"Testing &amp; Coverage","text":""},{"location":"reference/multi-collection-architecture/#test-suite","title":"Test Suite","text":"<ul> <li>11 new tests in <code>test_multi_collection.py</code></li> <li>All existing 109 tests still pass</li> <li>Total: 120 passing tests</li> </ul>"},{"location":"reference/multi-collection-architecture/#coverage","title":"Coverage","text":"<pre><code>chromasql/__init__.py              100%\nchromasql/adapters.py               75% (16 miss - edge cases)\nchromasql/analysis.py               93% (2 miss - rare branches)\nchromasql/ast.py                   100%\nchromasql/errors.py                100%\nchromasql/executor.py              100%\nchromasql/explain.py               100%\nchromasql/grammar.py               100%\nchromasql/multi_collection.py       77% (27 miss - error paths)\nchromasql/parser.py                100%\nchromasql/plan.py                  100%\nchromasql/planner.py               100%\n-----------------------------------------------------\nTOTAL                               96% coverage\n</code></pre>"},{"location":"reference/multi-collection-architecture/#key-test-scenarios-covered","title":"Key Test Scenarios Covered","text":"<ul> <li>\u2705 Routing based on single value (<code>WHERE model = 'Table'</code>)</li> <li>\u2705 Routing based on IN list (<code>WHERE model IN ('Table', 'Field')</code>)</li> <li>\u2705 Fallback when discriminator absent</li> <li>\u2705 Strict mode (error if discriminator missing)</li> <li>\u2705 Partial collection failures</li> <li>\u2705 Result merging with LIMIT/OFFSET</li> <li>\u2705 Both vector and filter-only queries</li> <li>\u2705 Adapter implementations</li> </ul>"},{"location":"reference/multi-collection-architecture/#files-modifiedcreated","title":"Files Modified/Created","text":""},{"location":"reference/multi-collection-architecture/#new-files","title":"New Files","text":"<ul> <li>\u2728 <code>chromasql/multi_collection.py</code> (393 lines) - Core multi-collection execution</li> <li>\u2728 <code>chromasql/adapters.py</code> (300 lines) - Pre-built adapters</li> <li>\u2728 <code>tests/chromasql/test_multi_collection.py</code> (412 lines) - Test suite</li> <li>\u2728 <code>chromasql/EXAMPLES.md</code> (500+ lines) - Usage examples</li> <li>\u2728 <code>chromasql/MULTI_COLLECTION_SUMMARY.md</code> (this file)</li> </ul>"},{"location":"reference/multi-collection-architecture/#modified-files","title":"Modified Files","text":"<ul> <li>\ud83d\udcdd <code>chromasql/__init__.py</code> - Export new APIs</li> <li>\ud83d\udcdd <code>chromasql/CONTRIBUTING.md</code> - Add multi-collection patterns section</li> </ul>"},{"location":"reference/multi-collection-architecture/#unchanged-all-tests-still-pass","title":"Unchanged (All Tests Still Pass)","text":"<ul> <li>\u2705 <code>chromasql/parser.py</code></li> <li>\u2705 <code>chromasql/planner.py</code></li> <li>\u2705 <code>chromasql/executor.py</code></li> <li>\u2705 <code>chromasql/ast.py</code></li> <li>\u2705 All other core modules</li> </ul>"},{"location":"reference/multi-collection-architecture/#next-steps","title":"Next Steps","text":""},{"location":"reference/multi-collection-architecture/#for-your-use-case","title":"For Your Use Case","text":"<ol> <li> <p>Try it out: <pre><code>poetry run python -m your_module\n</code></pre></p> </li> <li> <p>Monitor routing behavior:</p> </li> <li>Log <code>router.route(query)</code> results</li> <li>Track which collections are queried</li> <li> <p>Measure query latency improvements</p> </li> <li> <p>Tune performance:</p> </li> <li>Adjust <code>n_results_per_collection</code> if needed</li> <li>Consider adding more discriminators (e.g., environment, region)</li> </ol>"},{"location":"reference/multi-collection-architecture/#for-other-developers","title":"For Other Developers","text":"<ol> <li>Implement custom routers:</li> <li>Extend <code>CollectionRouter</code> protocol</li> <li>Use <code>extract_metadata_values()</code> helper</li> <li> <p>See examples in <code>EXAMPLES.md</code></p> </li> <li> <p>Contribute improvements:</p> </li> <li>Add support for nested metadata paths in analysis module</li> <li>Implement additional merge strategies (e.g., score blending)</li> <li> <p>Add async streaming for large result sets</p> </li> <li> <p>Documentation:</p> </li> <li>Add your routing strategy to <code>EXAMPLES.md</code></li> <li>Share patterns in discussions</li> </ol>"},{"location":"reference/multi-collection-architecture/#api-reference","title":"API Reference","text":""},{"location":"reference/multi-collection-architecture/#public-exports","title":"Public Exports","text":"<p>From <code>chromasql</code>: <pre><code>from chromasql import (\n    # Core API (unchanged)\n    parse, build_plan, execute_plan, plan_to_dict,\n    ExecutionResult, QueryPlan,\n\n    # Analysis helpers\n    extract_metadata_values,\n\n    # Multi-collection support\n    CollectionRouter,\n    AsyncCollectionProvider,\n    execute_multi_collection,\n\n    # Pre-built adapters\n    AsyncMultiCollectionAdapter,\n    MetadataFieldRouter,\n    SimpleAsyncClientAdapter,\n)\n</code></pre></p>"},{"location":"reference/multi-collection-architecture/#main-function-signature","title":"Main Function Signature","text":"<pre><code>async def execute_multi_collection(\n    query_str: str,\n    router: CollectionRouter,\n    collection_provider: AsyncCollectionProvider,\n    *,\n    embed_fn: Optional[EmbedFunction] = None,\n    merge_strategy: str = \"distance\",\n    n_results_per_collection: Optional[int] = None,\n) -&gt; ExecutionResult:\n    \"\"\"Execute a ChromaSQL query across multiple collections.\"\"\"\n</code></pre>"},{"location":"reference/multi-collection-architecture/#protocol-signatures","title":"Protocol Signatures","text":"<pre><code>class CollectionRouter(Protocol):\n    def route(self, query: Query) -&gt; Optional[Sequence[str]]:\n        \"\"\"Return collection names or None for all.\"\"\"\n\nclass AsyncCollectionProvider(Protocol):\n    async def get_collection(self, name: str) -&gt; Any:\n        \"\"\"Get collection by name.\"\"\"\n\n    async def list_collection_names(self) -&gt; Sequence[str]:\n        \"\"\"List all available collections.\"\"\"\n</code></pre>"},{"location":"reference/multi-collection-architecture/#questions-support","title":"Questions &amp; Support","text":"<p>For questions or issues:</p> <ol> <li>Check <code>EXAMPLES.md</code> for usage patterns</li> <li>Review <code>CONTRIBUTING.md</code> for architecture details</li> <li>Run tests: <code>poetry run pytest tests/chromasql/ -v</code></li> <li>Open an issue with reproduction steps</li> </ol> <p>Implementation completed: All tasks done \u2705 Test coverage: 96% overall, 120 tests passing Status: Ready for production use</p>"},{"location":"reference/routing-strategies/","title":"Multi-Collection Routing Playbook","text":"<p>This document provides comprehensive coverage of ChromaSQL's multi-collection routing strategies, including implementation details, edge cases, optimization analysis, and best practices.</p>"},{"location":"reference/routing-strategies/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Overview</li> <li>Routing Strategies</li> <li>OR Predicate Routing</li> <li>Optimization Analysis</li> <li>Implementation Details</li> <li>Performance Guide</li> <li>Testing &amp; Coverage</li> </ol>"},{"location":"reference/routing-strategies/#overview","title":"Overview","text":"<p>ChromaSQL's routing system determines which collections to query based on metadata discriminator fields in the WHERE clause. The goal is to maximize query efficiency while guaranteeing zero under-routing.</p>"},{"location":"reference/routing-strategies/#core-principles","title":"Core Principles","text":"<ol> <li>Zero Under-Routing: Never miss results because a collection wasn't queried</li> <li>Maximum Efficiency: Query the minimum set of collections needed for correctness</li> <li>Simplicity: Use clear, verifiable rules that are easy to reason about</li> </ol>"},{"location":"reference/routing-strategies/#how-it-works","title":"How It Works","text":"<pre><code>Query \u2192 Parser \u2192 Planner \u2192 Router \u2192 Collections\n                              \u2193\n                    extract_metadata_values()\n                              \u2193\n                    {discriminator values} or None\n                              \u2193\n                    Map to collections via query_config\n</code></pre>"},{"location":"reference/routing-strategies/#routing-strategies","title":"Routing Strategies","text":""},{"location":"reference/routing-strategies/#1-single-discriminator-value-optimal","title":"1. Single Discriminator Value (Optimal)","text":"<p>Query: <pre><code>WHERE metadata.model = 'Table'\n</code></pre></p> <p>Routing: - Extracts: <code>{'Table'}</code> - Routes to: Collections containing 'Table' (~2-3 out of 37) - Performance: Best case \u26a1</p>"},{"location":"reference/routing-strategies/#2-multiple-discriminator-values-union","title":"2. Multiple Discriminator Values (Union)","text":"<p>Query: <pre><code>WHERE metadata.model IN ('Table', 'Field', 'View')\n</code></pre></p> <p>Routing: - Extracts: <code>{'Table', 'Field', 'View'}</code> - Routes to: Union of collections for all three models (~6-9 out of 37) - Performance: Very efficient \u26a1\u26a1</p>"},{"location":"reference/routing-strategies/#3-and-with-discriminator-restrictive","title":"3. AND with Discriminator (Restrictive)","text":"<p>Query: <pre><code>WHERE metadata.model = 'Table' AND metadata.status = 'active'\n</code></pre></p> <p>Routing: - Extracts: <code>{'Table'}</code> - Routes to: Collections for 'Table' - Key Insight: AND restricts scope, only discriminator values matter - Performance: Optimal \u26a1</p>"},{"location":"reference/routing-strategies/#4-or-with-all-discriminators-union","title":"4. OR with All Discriminators (Union)","text":"<p>Query: <pre><code>WHERE (metadata.model = 'Table' AND metadata.system = 'S4')\n      OR (metadata.model = 'Field' AND metadata.required = TRUE)\n</code></pre></p> <p>Routing: - Extracts: <code>{'Table', 'Field'}</code> - Routes to: Union of collections for Table and Field - Key Insight: All OR branches have discriminators \u2192 efficient union - Performance: Efficient \u26a1\u26a1</p>"},{"location":"reference/routing-strategies/#5-or-with-missing-discriminator-conservative-fallback","title":"5. OR with Missing Discriminator (Conservative Fallback)","text":"<p>Query: <pre><code>WHERE metadata.model = 'Table' OR metadata.has_sem = FALSE\n</code></pre></p> <p>Routing: - Extracts: <code>None</code> (fallback signal) - Routes to: ALL collections - Why: Second OR branch could match records in ANY collection - Performance: Conservative but correct \ud83d\udc22</p> <p>Optimization: <pre><code>-- If you want only Table records, use AND:\nWHERE metadata.model = 'Table' AND metadata.has_sem = FALSE\n\u2192 Routes to Table collections only \u26a1\n</code></pre></p>"},{"location":"reference/routing-strategies/#6-no-discriminator-fallback","title":"6. No Discriminator (Fallback)","text":"<p>Query: <pre><code>WHERE metadata.status = 'active' AND metadata.year &gt; 2020\n</code></pre></p> <p>Routing: - Extracts: <code>None</code> (no discriminator found) - Routes to: ALL collections - Performance: Full scan \ud83d\udc22</p>"},{"location":"reference/routing-strategies/#or-predicate-routing","title":"OR Predicate Routing","text":"<p>This section details edge cases and behaviors specific to OR predicates.</p>"},{"location":"reference/routing-strategies/#the-or-rule","title":"The OR Rule","text":"<p>For OR predicates: If ANY branch lacks the discriminator field, we must query all collections to prevent under-routing.</p> <pre><code>if any(len(branch_vals) == 0 for branch_vals in branch_values_list):\n    return set()  # Signal: query all collections\n</code></pre>"},{"location":"reference/routing-strategies/#edge-cases-catalog","title":"Edge Cases Catalog","text":""},{"location":"reference/routing-strategies/#1-simple-or-with-same-field","title":"1. Simple OR with Same Field \u2705","text":"<p>Query: <pre><code>WHERE metadata.model = 'Table' OR metadata.model = 'Field'\n</code></pre></p> <p>Behavior: - Extracts: <code>{'Table', 'Field'}</code> - Routes to: Union of Table and Field collections - Test: <code>test_extract_metadata_values_with_or_single_field</code></p>"},{"location":"reference/routing-strategies/#2-or-with-different-fields-triggers-fallback","title":"2. OR with Different Fields (Triggers Fallback) \u26a0\ufe0f","text":"<p>Query: <pre><code>WHERE metadata.model = 'Table' OR metadata.has_sem = FALSE\n</code></pre></p> <p>Behavior: - Extracts: <code>None</code> (fallback) - Routes to: ALL collections - Why: <code>has_sem = FALSE</code> could match records in any collection - Test: <code>test_extract_metadata_values_with_or_different_fields</code></p>"},{"location":"reference/routing-strategies/#3-or-with-nested-and","title":"3. OR with Nested AND \u2705","text":"<p>Query: <pre><code>WHERE metadata.model = 'Table'\n      OR (metadata.model = 'Field' AND metadata.fieldname = 'lang')\n</code></pre></p> <p>Behavior: - Extracts: <code>{'Table', 'Field'}</code> - Routes to: Union of Table and Field collections - Why: Both OR branches contain discriminators - Test: <code>test_extract_or_with_nested_and</code></p>"},{"location":"reference/routing-strategies/#4-multiple-or-branches-with-and","title":"4. Multiple OR Branches with AND \u2705","text":"<p>Query: <pre><code>WHERE (metadata.model = 'Table' AND metadata.system = 'S4')\n      OR (metadata.model = 'Field' AND metadata.fieldname = 'lang')\n      OR (metadata.model = 'View' AND metadata.active = TRUE)\n</code></pre></p> <p>Behavior: - Extracts: <code>{'Table', 'Field', 'View'}</code> - Routes to: Union of all three models - Test: <code>test_extract_complex_or_with_multiple_nested_ands</code></p>"},{"location":"reference/routing-strategies/#5-deeply-nested-orand","title":"5. Deeply Nested OR/AND \u2705","text":"<p>Query: <pre><code>WHERE (\n    (metadata.model = 'Table' AND metadata.system = 'ECC')\n    OR (\n        metadata.model = 'Field'\n        AND (metadata.type = 'CHAR' OR metadata.type = 'NUMC')\n    )\n) OR metadata.model = 'View'\n</code></pre></p> <p>Behavior: - Extracts: <code>{'Table', 'Field', 'View'}</code> - Routes to: Union of all three models - Handles arbitrary nesting depth - Test: <code>test_extract_deeply_nested_or_and</code></p>"},{"location":"reference/routing-strategies/#6-or-with-partial-discriminators-triggers-fallback","title":"6. OR with Partial Discriminators (Triggers Fallback) \u26a0\ufe0f","text":"<p>Query: <pre><code>WHERE (metadata.status = 'active' AND metadata.year &gt; 2020)\n      OR metadata.model = 'Table'\n      OR (metadata.has_sem = TRUE AND metadata.env = 'prod')\n</code></pre></p> <p>Behavior: - Extracts: <code>None</code> (fallback) - Routes to: ALL collections - Why: Branches 1 and 3 lack discriminators - Test: <code>test_extract_or_with_only_one_branch_having_target_field</code></p>"},{"location":"reference/routing-strategies/#7-complex-andor-within-and-context","title":"7. Complex AND/OR Within AND Context \u2705","text":"<p>Query: <pre><code>WHERE metadata.environment = 'prod'\n      AND (metadata.model = 'Table' OR metadata.model = 'Field')\n      AND metadata.year &gt; 2020\n</code></pre></p> <p>Behavior: - Extracts: <code>{'Table', 'Field'}</code> - Routes to: Union of Table and Field collections - Why: Top-level AND doesn't affect OR union extraction - Test: <code>test_extract_with_complex_or_and_and</code></p>"},{"location":"reference/routing-strategies/#8-deduplication-of-overlapping-collections","title":"8. Deduplication of Overlapping Collections \u2705","text":"<p>Query: <pre><code>WHERE metadata.model = 'Table' OR metadata.model = 'Field'\n</code></pre></p> <p>Setup: - Table \u2192 [coll_1, shared_coll] - Field \u2192 [coll_2, shared_coll]</p> <p>Behavior: - Routes to: <code>[coll_1, coll_2, shared_coll]</code> (deduplicated) - Ensures <code>shared_coll</code> is only queried once - Test: <code>test_router_deduplicates_collections_in_union</code></p>"},{"location":"reference/routing-strategies/#or-routing-summary-table","title":"OR Routing Summary Table","text":"Query Pattern Extracts Routes To Performance <code>A OR B</code> (both discriminators) {A, B} A \u222a B \u26a1\u26a1 Efficient <code>A OR (B AND x)</code> (both have discriminators) {A, B} A \u222a B \u26a1\u26a1 Efficient <code>A OR x</code> (second lacks discriminator) None ALL \ud83d\udc22 Fallback <code>(A AND x) OR (B AND y)</code> {A, B} A \u222a B \u26a1\u26a1 Efficient <code>(x AND y) OR A OR (z AND w)</code> None ALL \ud83d\udc22 Fallback"},{"location":"reference/routing-strategies/#optimization-analysis","title":"Optimization Analysis","text":"<p>This section documents deep analysis of the routing algorithm to verify optimality.</p>"},{"location":"reference/routing-strategies/#research-question","title":"Research Question","text":"<p>\"Can we optimize the routing algorithm to be more efficient while maintaining zero under-routing?\"</p>"},{"location":"reference/routing-strategies/#test-cases-analyzed","title":"Test Cases Analyzed","text":"<pre><code># Test 1: AND with discriminator + OR without\nWHERE model = 'Table' AND (status = 'active' OR year &gt; 2020)\n\u2192 Result: {'Table'} \u2705 Optimal\n\n# Test 2: Nested OR with one branch lacking discriminator\nWHERE (model = 'Table' OR model = 'Field') OR (model = 'View' OR status = 'active')\n\u2192 Result: None (ALL) \u2705 Correct (conservative)\n\n# Test 3: User's case - OR with nested AND\nWHERE model = 'Table' OR (model = 'Field' AND fieldname = 'lang')\n\u2192 Result: {'Table', 'Field'} \u2705 Optimal\n\n# Test 4: Multiple AND branches in OR\nWHERE (model = 'Table' AND system = 'S4') OR (model = 'Field' AND required = TRUE)\n\u2192 Result: {'Table', 'Field'} \u2705 Optimal\n\n# Test 5: AND with two ORs (semantic impossibility)\nWHERE (model = 'Table' OR model = 'Field') AND (model = 'View' OR model = 'Function')\n\u2192 Result: {'Table', 'Field', 'View', 'Function'} \u2705 Union of all\n\n# Test 6: Triple-nested AND&gt;OR&gt;AND\nWHERE model = 'Table' AND (status = 'X' OR (model = 'Field' AND year &gt; 2020))\n\u2192 Result: {'Table'} \u2705 Optimal\n\n# Test 7: Pure non-discriminator query\nWHERE status = 'active' AND year &gt; 2020\n\u2192 Result: None (ALL) \u2705 Correct\n\n# Test 8: NOT IN (should not extract)\nWHERE model NOT IN ('Table', 'Field')\n\u2192 Result: None (ALL) \u2705 Correct (can't route on negation)\n</code></pre> <p>All 8 test cases passed! \u2705</p>"},{"location":"reference/routing-strategies/#algorithm-rules","title":"Algorithm Rules","text":"<p>The algorithm uses two complementary rules:</p>"},{"location":"reference/routing-strategies/#rule-1-or-rule-conservative","title":"Rule 1: OR Rule (Conservative)","text":"<pre><code>if predicate.operator == \"OR\":\n    # Check if ANY branch lacks discriminator\n    if any(len(branch_vals) == 0 for branch_vals in branch_values_list):\n        return set()  # Fallback - prevents under-routing\n\n    # Otherwise, take union\n    for branch_vals in branch_values_list:\n        values.update(branch_vals)\n    return values\n</code></pre> <p>Rationale: If any OR branch lacks the discriminator, that branch could match records in any collection \u2192 must query all.</p>"},{"location":"reference/routing-strategies/#rule-2-and-rule-optimistic","title":"Rule 2: AND Rule (Optimistic)","text":"<pre><code>else:  # AND\n    # Collect from all branches\n    for child in predicate.predicates:\n        values.update(_collect_metadata_values(child, path))\n    return values\n</code></pre> <p>Rationale: AND restricts results to records satisfying all conditions \u2192 union discriminators from all branches.</p>"},{"location":"reference/routing-strategies/#why-this-is-optimal","title":"Why This Is Optimal","text":"<p>Mathematical Property: The algorithm achieves the maximal routing efficiency subject to the constraint of zero under-routing.</p> <p>Proof Sketch: 1. Soundness (Zero Under-Routing): Any query result matches at least one OR branch. If a branch lacks discriminators, we fallback to all collections, guaranteeing we query the collection containing that result. 2. Completeness (Maximum Efficiency): If all OR branches have discriminators, we extract the union of discriminator values, which is the minimal set of collections needed to cover all possible results. 3. Optimality: Any further \"optimization\" would either (a) introduce under-routing risk, or (b) add complexity without efficiency gain.</p>"},{"location":"reference/routing-strategies/#rejected-optimizations","title":"Rejected Optimizations","text":"<p>We considered several potential optimizations and rejected them:</p>"},{"location":"reference/routing-strategies/#partial-or-optimization","title":"\u274c Partial OR Optimization","text":"<p>Idea: For <code>WHERE model IN ('A', 'B') OR status='X'</code>, query union of (A\u222aB\u222aall_others)?</p> <p>Rejected Because: - Complex and error-prone - Still queries almost all collections anyway - Risk of bugs in \"all_others\" calculation</p>"},{"location":"reference/routing-strategies/#cost-based-fallback","title":"\u274c Cost-Based Fallback","text":"<p>Idea: If union exceeds 80% of collections, just query all?</p> <p>Rejected Because: - This is a performance tweak, not a correctness improvement - Should be handled at a different layer (query planner) - Adds complexity to routing logic</p>"},{"location":"reference/routing-strategies/#smart-or-pruning","title":"\u274c Smart OR Pruning","text":"<p>Idea: Analyze which OR branches are \"dominant\" and skip others?</p> <p>Rejected Because: - Would introduce under-routing risk - Complex to implement correctly - Violates the zero under-routing guarantee</p>"},{"location":"reference/routing-strategies/#conclusion","title":"Conclusion","text":"<p>The current implementation is OPTIMAL \u2705</p> <p>No additional logic needed. The algorithm achieves perfect balance: - \u2705 Zero under-routing (correctness) - \u2705 Maximum efficiency (performance) - \u2705 Simple &amp; maintainable (clarity)</p> <p>Any further \"optimization\" would compromise one of these properties.</p>"},{"location":"reference/routing-strategies/#recommended-enhancement-logging","title":"Recommended Enhancement: Logging","text":"<p>The only suggested improvement is user-facing logging when fallback occurs:</p> <pre><code>if any(len(branch_vals) == 0 for branch_vals in branch_values_list):\n    logger.info(\"OR predicate has branch without discriminator - querying all collections for correctness\")\n    return set()\n</code></pre> <p>This helps users understand query performance and optimize their queries accordingly.</p>"},{"location":"reference/routing-strategies/#implementation-details","title":"Implementation Details","text":""},{"location":"reference/routing-strategies/#extraction-algorithm","title":"Extraction Algorithm","text":"<p>The <code>extract_metadata_values()</code> function in chromasql/analysis.py:</p> <pre><code>def _collect_metadata_values(predicate: Predicate, path: Tuple[str, ...]) -&gt; Set[str]:\n    \"\"\"Collect metadata values from predicate tree.\n\n    Returns empty set if we should query all collections (prevents under-routing).\n    \"\"\"\n    if isinstance(predicate, BooleanPredicate):\n        if predicate.operator == \"OR\":\n            # Check if ANY branch lacks discriminator\n            branch_values_list = []\n            for child in predicate.predicates:\n                branch_values = _collect_metadata_values(child, path)\n                branch_values_list.append(branch_values)\n\n            if any(len(branch_vals) == 0 for branch_vals in branch_values_list):\n                return set()  # Signal: query all collections\n\n            # Union of all branch values\n            values = set()\n            for branch_vals in branch_values_list:\n                values.update(branch_vals)\n            return values\n        else:  # AND\n            # Collect from all branches\n            values = set()\n            for child in predicate.predicates:\n                values.update(_collect_metadata_values(child, path))\n            return values\n\n    if isinstance(predicate, ComparisonPredicate):\n        if predicate.operator == \"=\" and _matches_field(predicate.field, path):\n            return {predicate.value}\n        return set()\n\n    if isinstance(predicate, InPredicate):\n        if not predicate.negated and _matches_field(predicate.field, path):\n            return set(predicate.values)\n        return set()\n\n    return set()\n</code></pre>"},{"location":"reference/routing-strategies/#router-logic","title":"Router Logic","text":"<p>The <code>MetadataFieldRouter</code> in chromasql/adapters.py:</p> <ol> <li>Calls <code>extract_metadata_values()</code> to get discriminator values</li> <li>Maps each value to collections via <code>query_config</code></li> <li>Takes union of all collection lists</li> <li>Deduplicates the final list</li> <li>Returns <code>None</code> if no values found \u2192 triggers fallback</li> </ol>"},{"location":"reference/routing-strategies/#query-config-format","title":"Query Config Format","text":"<pre><code>{\n  \"model_to_collections\": {\n    \"Table\": {\n      \"collections\": [\"coll_1\", \"coll_2\"],\n      \"total_documents\": 1000,\n      \"partitions\": [\"partition_1\"]\n    },\n    \"Field\": {\n      \"collections\": [\"coll_3\"],\n      \"total_documents\": 500,\n      \"partitions\": [\"partition_2\"]\n    }\n  },\n  \"collection_to_models\": {\n    \"coll_1\": [\"Table\"],\n    \"coll_2\": [\"Table\"],\n    \"coll_3\": [\"Field\"]\n  }\n}\n</code></pre>"},{"location":"reference/routing-strategies/#performance-guide","title":"Performance Guide","text":""},{"location":"reference/routing-strategies/#query-optimization-tips","title":"Query Optimization Tips","text":""},{"location":"reference/routing-strategies/#do-use-discriminators-in-where","title":"\u2705 DO: Use discriminators in WHERE","text":"<pre><code>-- Good: Routes to Table collections only\nSELECT * FROM sap_data\nWHERE metadata.model = 'Table' AND metadata.status = 'active'\n</code></pre>"},{"location":"reference/routing-strategies/#do-use-or-with-discriminators","title":"\u2705 DO: Use OR with discriminators","text":"<pre><code>-- Good: Routes to union of Table and Field\nSELECT * FROM sap_data\nWHERE metadata.model = 'Table' OR metadata.model = 'Field'\n</code></pre>"},{"location":"reference/routing-strategies/#do-use-in-for-multiple-values","title":"\u2705 DO: Use IN for multiple values","text":"<pre><code>-- Good: Equivalent to OR, often more readable\nSELECT * FROM sap_data\nWHERE metadata.model IN ('Table', 'Field', 'View')\n</code></pre>"},{"location":"reference/routing-strategies/#caution-or-without-discriminator-triggers-fallback","title":"\u26a0\ufe0f CAUTION: OR without discriminator triggers fallback","text":"<pre><code>-- Queries ALL collections (conservative)\nSELECT * FROM sap_data\nWHERE metadata.model = 'Table' OR metadata.has_sem = FALSE\n</code></pre> <p>Optimization: Use AND instead: <pre><code>-- Routes to Table collections only\nSELECT * FROM sap_data\nWHERE metadata.model = 'Table' AND metadata.has_sem = FALSE\n</code></pre></p>"},{"location":"reference/routing-strategies/#caution-no-discriminator-full-scan","title":"\u26a0\ufe0f CAUTION: No discriminator = full scan","text":"<pre><code>-- Queries ALL collections\nSELECT * FROM sap_data\nWHERE metadata.status = 'active'\n</code></pre> <p>Optimization: Add discriminator filter: <pre><code>-- Routes to Table collections only\nSELECT * FROM sap_data\nWHERE metadata.model = 'Table' AND metadata.status = 'active'\n</code></pre></p>"},{"location":"reference/routing-strategies/#performance-matrix","title":"Performance Matrix","text":"Query Type Collections Queried Performance Example Single discriminator 2-3 / 37 \u26a1\u26a1\u26a1 Best <code>model = 'Table'</code> Multiple discriminators 6-9 / 37 \u26a1\u26a1 Very Good <code>model IN ('A', 'B', 'C')</code> Union routing (10 values) ~20 / 37 \u26a1 Acceptable Large OR/IN list Fallback (mixed OR) 37 / 37 \ud83d\udc22 Conservative <code>model = 'A' OR x = 1</code> No discriminator 37 / 37 \ud83d\udc22 Full Scan <code>status = 'active'</code>"},{"location":"reference/routing-strategies/#performance-monitoring","title":"Performance Monitoring","text":"<p>Use verbose logging to see routing decisions:</p> <pre><code>async with QueryExecutor(..., fallback_to_all=True) as executor:\n    result = await executor.execute(\"SELECT ...\")\n    print(f\"Collections queried: {result.collections_queried}\")\n</code></pre>"},{"location":"reference/routing-strategies/#testing-coverage","title":"Testing &amp; Coverage","text":""},{"location":"reference/routing-strategies/#test-organization","title":"Test Organization","text":"<pre><code>tests/chromasql/\n\u251c\u2500\u2500 test_or_routing.py              # Unit tests for extraction logic (13 tests)\n\u251c\u2500\u2500 test_or_routing_integration.py  # Router integration tests (11 tests)\n\u251c\u2500\u2500 test_multi_collection.py        # Multi-collection execution (10 tests)\n\u2514\u2500\u2500 test_analysis.py                # Analysis helper tests (3 tests)\n\nTotal: 37 tests covering routing logic\n</code></pre>"},{"location":"reference/routing-strategies/#coverage-summary","title":"Coverage Summary","text":"Category Tests Status Basic OR extraction 3 \u2705 All Passing Nested OR/AND combinations 6 \u2705 All Passing Fallback scenarios 2 \u2705 All Passing Router integration 11 \u2705 All Passing Multi-collection execution 10 \u2705 All Passing Analysis helpers 3 \u2705 All Passing Optimization analysis 8 \u2705 All Passing Total 43 \u2705 All Passing"},{"location":"reference/routing-strategies/#running-tests","title":"Running Tests","text":"<pre><code># Run all routing tests\npoetry run pytest tests/chromasql/test_or_routing*.py -v\n\n# Run with coverage\npoetry run pytest tests/chromasql/ --cov=chromasql.analysis --cov=chromasql.adapters\n\n# Run specific edge case\npoetry run pytest tests/chromasql/test_or_routing.py::test_extract_or_with_nested_and -v\n</code></pre>"},{"location":"reference/routing-strategies/#anti-patterns","title":"Anti-Patterns","text":""},{"location":"reference/routing-strategies/#partial-routing-for-mixed-or","title":"\u274c Partial Routing for Mixed OR","text":"<p>Bad Approach: <pre><code>WHERE metadata.model = 'Table' OR metadata.has_sem = FALSE\n\u2192 Routes ONLY to 'Table' collections\n\u2192 PROBLEM: Misses records in other collections where has_sem = FALSE!\n</code></pre></p> <p>ChromaSQL's Approach: <pre><code>WHERE metadata.model = 'Table' OR metadata.has_sem = FALSE\n\u2192 Routes to ALL collections (fallback)\n\u2192 RESULT: No under-routing, all matching records found \u2705\n</code></pre></p>"},{"location":"reference/routing-strategies/#correct-pattern-use-and-for-specificity","title":"\u2705 Correct Pattern: Use AND for Specificity","text":"<pre><code>WHERE metadata.model = 'Table' AND metadata.has_sem = FALSE\n\u2192 Routes to 'Table' collections only\n\u2192 RESULT: Only Table records with has_sem = FALSE \u2705\n</code></pre>"},{"location":"reference/routing-strategies/#references","title":"References","text":""},{"location":"reference/routing-strategies/#source-code","title":"Source Code","text":"<ul> <li>chromasql/analysis.py - Metadata value extraction</li> <li>chromasql/adapters.py - MetadataFieldRouter implementation</li> <li>chromasql/multi_collection.py - Multi-collection execution</li> </ul> <p>Document Version: 1.0</p> <p>Release Date: November 1, 2025</p> <p>Test Coverage: 43/43 tests passing</p> <p>Total Project Tests: 151 (chromasql + query_lib)</p>"},{"location":"using-chromasql/quick-reference/","title":"ChromaSQL Query Clause Reference","text":"<p>ChromaSQL offers a compact set of clauses tailored to ChromaDB. This page is a quick reference; for a narrative walkthrough see the tutorial series.</p>"},{"location":"using-chromasql/quick-reference/#query-skeleton","title":"Query Skeleton","text":"<pre><code>SELECT projection\nFROM collection [AS alias]\n[WHERE ...]\n[WHERE_DOCUMENT ...]\n[USING EMBEDDING (...)]\n[SIMILARITY COSINE|L2|IP]\n[TOPK n]\n[ORDER BY ...]\n[RERANK BY MMR(...)]\n[LIMIT n]\n[OFFSET n]\n[WITH SCORE THRESHOLD x]\n</code></pre> <p>Clauses can appear in any order allowed by the grammar (see the Grammar Specification for details). <code>USING EMBEDDING</code> switches the query into vector mode; omitting it produces a metadata-only <code>get</code>.</p>"},{"location":"using-chromasql/quick-reference/#projection","title":"Projection","text":"<ul> <li><code>SELECT *</code> returns <code>id</code>, <code>distance</code>, <code>document</code>, and <code>metadata</code>.</li> <li><code>metadata.foo.bar</code> projects nested metadata.</li> <li><code>SELECT metadata.price AS price_usd</code> applies aliases.</li> </ul>"},{"location":"using-chromasql/quick-reference/#filtering","title":"Filtering","text":""},{"location":"using-chromasql/quick-reference/#metadata-where","title":"Metadata (<code>WHERE</code>)","text":"<p>Supports equality, inequality, numeric comparisons, <code>IN</code>/<code>NOT IN</code>, and <code>BETWEEN</code>.</p> <p>Note: <code>LIKE</code> and <code>CONTAINS</code> are NOT supported on metadata (ChromaDB limitation). Use <code>WHERE_DOCUMENT</code> for text/pattern matching.</p> <p>Note: <code>BETWEEN</code> with mixed int/float types may behave unexpectedly due to ChromaDB type coercion. Use matching types (integer boundaries for integer metadata).</p> <p>Important: Different filter types (metadata vs. document) can only be combined with <code>AND</code>, not <code>OR</code> (ChromaDB limitation). Within each type, use <code>OR</code> freely.</p> <pre><code>-- Valid: metadata AND document\nWHERE metadata.category = 'outerwear'\n  AND metadata.price BETWEEN 50 AND 150\n  AND document CONTAINS 'waterproof'\n\n-- Invalid: metadata OR document \u274c\n-- WHERE metadata.category = 'outerwear' OR document CONTAINS 'sale'\n</code></pre>"},{"location":"using-chromasql/quick-reference/#document-where_document","title":"Document (<code>WHERE_DOCUMENT</code>)","text":"<p>Applied after metadata filters. Supports text search operators: <code>CONTAINS</code>, <code>NOT CONTAINS</code>, <code>LIKE</code>, <code>NOT LIKE</code>, <code>REGEX</code>, <code>NOT REGEX</code>.</p> <p>These operators ONLY work with WHERE_DOCUMENT, not with WHERE (metadata).</p> <p>Boolean expressions supported: Use <code>AND</code>, <code>OR</code>, and parentheses for complex filters.</p> <p>Important: Use <code>WHERE_DOCUMENT</code> once at the beginning, then combine predicates with boolean operators. Don't repeat <code>WHERE_DOCUMENT</code> for each condition.</p> <pre><code>-- Simple filter\nWHERE_DOCUMENT LIKE '%gore-tex%'\n\n-- OR: Match multiple terms (don't repeat WHERE_DOCUMENT!)\nWHERE_DOCUMENT CONTAINS 'waterproof' OR CONTAINS 'breathable'\n\n-- AND: Match all terms\nWHERE_DOCUMENT CONTAINS 'outdoor' AND LIKE '%jacket%'\n\n-- Complex: Nested with parentheses\nWHERE_DOCUMENT (CONTAINS 'outdoor' AND LIKE '%jacket%') OR CONTAINS 'windproof'\n\n-- Real-world: Multiple organization names\nWHERE_DOCUMENT CONTAINS 'BofA' OR CONTAINS 'Bank of America' OR LIKE '%Wells Fargo%'\n\n-- Exclude patterns\nWHERE_DOCUMENT NOT LIKE '%test%'\nWHERE_DOCUMENT NOT CONTAINS 'deprecated'\n\n-- Regex patterns\nWHERE_DOCUMENT REGEX '[a-z]+@[a-z]+\\.com'  -- Email pattern\nWHERE_DOCUMENT REGEX '(?i)python'  -- Case-insensitive matching\nWHERE_DOCUMENT NOT REGEX '\\d{3}-\\d{2}-\\d{4}'  -- Exclude SSN patterns\n</code></pre> <p>Note: Text operators are case-sensitive. <code>WHERE_DOCUMENT CONTAINS 'urgent'</code> will NOT match \"Urgent\" or \"URGENT\". To handle multiple cases, use OR: <code>CONTAINS 'urgent' OR CONTAINS 'Urgent'</code>, or use REGEX with <code>(?i)</code> flag: <code>REGEX '(?i)urgent'</code>.</p>"},{"location":"using-chromasql/quick-reference/#embedding-clauses","title":"Embedding Clauses","text":"<pre><code>USING EMBEDDING (TEXT 'query' [MODEL 'model'])\nUSING EMBEDDING (VECTOR [0.1, 0.2, 0.3])\nUSING EMBEDDING BATCH (\n  TEXT 'first',\n  VECTOR [0.4, 0.5, 0.6]\n)\n</code></pre> <p>Batch queries return results for each item independently.</p>"},{"location":"using-chromasql/quick-reference/#ordering-pagination","title":"Ordering &amp; Pagination","text":"<ul> <li>Vector queries default to <code>ORDER BY distance ASC</code>.</li> <li>Metadata fields and <code>id</code> are allowed in <code>ORDER BY</code>.</li> <li>Filter-only queries cannot sort by distance.</li> </ul> <p>Pagination follows SQL semantics: <code>LIMIT</code> + <code>OFFSET</code> are applied after ordering.</p>"},{"location":"using-chromasql/quick-reference/#score-thresholds","title":"Score Thresholds","text":"<pre><code>WITH SCORE THRESHOLD 0.25\n</code></pre> <p>Post-filter results by distance (lower is better). Useful when the top-k results drift beyond an acceptable score.</p>"},{"location":"using-chromasql/quick-reference/#rerank-hints","title":"Rerank Hints","text":"<pre><code>RERANK BY MMR(lambda = 0.4, candidates = 50)\n</code></pre>"},{"location":"using-chromasql/quick-reference/#explain","title":"Explain","text":"<p>Prefix a query with <code>EXPLAIN</code> to inspect the plan:</p> <pre><code>EXPLAIN\nSELECT id, distance\nFROM products\nUSING EMBEDDING (TEXT 'chair')\nTOPK 5;\n</code></pre> <p>The planner returns a <code>QueryPlan</code> with execution mode, includes, filters, and other metadata, which you can serialize via <code>plan_to_dict</code>.</p>"},{"location":"using-chromasql/tutorial/basics/","title":"Build Your First Query","text":""},{"location":"using-chromasql/tutorial/basics/#start-with-the-smallest-query","title":"Start with the Smallest Query","text":"<pre><code>SELECT *\nFROM products;\n</code></pre> <ul> <li>Returns the default set of columns (<code>id</code>, <code>distance</code>, <code>document</code>, <code>metadata</code>).</li> <li>Works on a single collection.  There is no <code>JOIN</code> support \u2013 run multiple   queries and merge results in Python if you need cross-collection logic.</li> </ul> <p>Myth</p> <p><code>SELECT *</code> fetches everything, including embeddings.  In reality embeddings are excluded. </p> <p>If you need vectors, you must explicitly include the <code>embedding</code> column in the query.</p>"},{"location":"using-chromasql/tutorial/basics/#choose-your-projection","title":"Choose Your Projection","text":"<pre><code>SELECT id, document, metadata.category\nFROM products;\n</code></pre> <ul> <li><code>metadata.category</code> drills into nested metadata.</li> </ul> <p>Schema context</p> <p><code>metadata.category</code> and <code>metadata.price</code> are metadata keys on the sample <code>products</code> collection described above.</p> <ul> <li>Use <code>AS</code> to rename columns:</li> </ul> <pre><code>SELECT metadata.price AS price_usd FROM products;\n</code></pre> <p>Tip</p> <p><code>metadata.foo</code> pulls from your metadata JSON, not the document.</p> <p>Fields stored directly on the document (via <code>document</code>) are separate.</p> <ul> <li> Need Help?   Check the troubleshooting guide for fixes to the most common ChromaSQL hiccups.</li> </ul>"},{"location":"using-chromasql/tutorial/explain/","title":"Inspect Plans with <code>EXPLAIN</code>","text":"<p><pre><code>EXPLAIN\nSELECT id, distance\nFROM products\nUSING EMBEDDING (TEXT 'mesh office chair')\nTOPK 5;\n</code></pre> * Returns the plan dictionary (collection name, include fields, where payload,   rerank hints, etc.) without hitting ChromaDB. * Useful for debugging or to understand how clauses are mapped before execution.</p> <p>Dry-run complex queries</p> <p>Use <code>EXPLAIN</code> while iterating on new clauses so you can inspect the planned payloads without burning ChromaDB capacity.</p> <ul> <li> Need Help?   Check the troubleshooting guide for fixes to the most common ChromaSQL hiccups.</li> </ul>"},{"location":"using-chromasql/tutorial/filter-only/","title":"Run Filter-Only Retrieval using <code>get</code>","text":"<p><pre><code>SELECT id, metadata\nFROM products\nWHERE metadata.category = 'accessories'\nORDER BY metadata.price ASC\nLIMIT 50;\n</code></pre> * Without a <code>USING EMBEDDING</code> clause the planner automatically switches to the   filter-only path (<code>collection.get</code>). * <code>distance</code> cannot be selected or ordered in this mode.</p> <p>Schema context</p> <p>This example filters by <code>metadata.category</code> and orders by <code>metadata.price</code>, both standard keys in the demo schema.</p> <p>Cheaper metadata lookups</p> <p>Filter-only queries never touch the embedding store, so they\u2019re usually cheaper.  If you only need metadata lookups, prefer this mode.</p> <ul> <li> Need Help?   Check the troubleshooting guide for fixes to the most common ChromaSQL hiccups.</li> </ul>"},{"location":"using-chromasql/tutorial/filtering/","title":"Filter ChromaSQL Results","text":""},{"location":"using-chromasql/tutorial/filtering/#filter-on-metadata-with-where","title":"Filter on Metadata with <code>WHERE</code>","text":"<pre><code>SELECT id, metadata\nFROM products\nWHERE metadata.category = 'outerwear'\n  AND metadata.price BETWEEN 50 AND 150;\n</code></pre> <p>Schema context</p> <p><code>metadata.price</code> is a numeric key on our demo schema.</p> <p>CONTAINS not supported on metadata</p> <p>The example previously showed <code>metadata.tags CONTAINS 'waterproof'</code> but this is NOT supported due to ChromaDB limitations. Use <code>WHERE_DOCUMENT CONTAINS 'waterproof'</code> to search document text instead, or use <code>metadata.tags IN ('waterproof', 'breathable')</code> for exact list matching.</p>"},{"location":"using-chromasql/tutorial/filtering/#supported-operators-inside-where","title":"Supported operators inside <code>WHERE</code>","text":"Operator Meaning <code>=</code>/<code>!=</code> equality / inequality <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> numeric comparisons <code>IN</code>, <code>NOT IN</code> membership tests on lists <code>BETWEEN</code> inclusive numeric range <p>LIKE and CONTAINS not supported on metadata</p> <p><code>LIKE</code> and <code>CONTAINS</code> operators only work with <code>WHERE_DOCUMENT</code> for filtering document text, not with <code>WHERE</code> for metadata fields. This is a ChromaDB limitation. Use exact matches (<code>=</code>, <code>IN</code>) or numeric comparisons for metadata filtering.</p> <p>Numeric type coercion with BETWEEN</p> <p>ChromaDB may coerce types when comparing integer metadata with float boundaries. For example, <code>BETWEEN 1500.5 AND 3500.5</code> on integer metadata might behave unexpectedly. For reliable results, use integer boundaries (<code>BETWEEN 1500 AND 3500</code>) when your metadata values are integers.</p> <p>Cannot OR different filter types</p> <p>ChromaDB limitation: You can only combine metadata and document filters with AND, not OR.</p> <p>\u2705 Valid: <pre><code>WHERE metadata.category = 'finance' AND document CONTAINS 'payment'\nWHERE (metadata.status = 'urgent' OR metadata.amount &gt; 5000) AND document CONTAINS 'invoice'\n</code></pre></p> <p>\u274c Invalid: <pre><code>WHERE metadata.category = 'finance' OR document CONTAINS 'payment'\n</code></pre></p> <p>Within each filter type (all metadata or all document), you can use OR freely.</p>"},{"location":"using-chromasql/tutorial/filtering/#filter-the-document-body-with-where_document","title":"Filter the Document Body with <code>WHERE_DOCUMENT</code>","text":"<pre><code>SELECT id, document\nFROM products\nWHERE metadata.category = 'outerwear'\nWHERE_DOCUMENT CONTAINS 'gore-tex';\n</code></pre> <ul> <li><code>WHERE_DOCUMENT</code> is evaluated after metadata filters.</li> <li>Text operators (<code>CONTAINS</code>, <code>NOT CONTAINS</code>, <code>LIKE</code>, <code>NOT LIKE</code>, <code>REGEX</code>, <code>NOT REGEX</code>) only work with WHERE_DOCUMENT, not with WHERE (metadata filters).</li> <li>Boolean expressions are supported: Use <code>AND</code>, <code>OR</code>, and parentheses to create complex document filters.</li> </ul> <p>Common Mistake: Don't Repeat WHERE_DOCUMENT</p> <p>\u274c INCORRECT - This will cause a parse error: <pre><code>WHERE_DOCUMENT CONTAINS 'vendor' OR WHERE_DOCUMENT CONTAINS 'payee'\n</code></pre></p> <p>\u2705 CORRECT - Use <code>WHERE_DOCUMENT</code> once, then combine with boolean operators: <pre><code>WHERE_DOCUMENT CONTAINS 'vendor' OR CONTAINS 'payee'\n</code></pre></p> <p>Think of <code>WHERE_DOCUMENT</code> as introducing a boolean expression, not as part of each condition.</p>"},{"location":"using-chromasql/tutorial/filtering/#examples-with-boolean-expressions","title":"Examples with Boolean Expressions","text":"<pre><code>-- Match documents containing either 'waterproof' OR 'breathable'\nSELECT id FROM products\nWHERE_DOCUMENT CONTAINS 'waterproof' OR CONTAINS 'breathable';\n\n-- Match documents containing both 'gore-tex' AND 'jacket'\nSELECT id FROM products\nWHERE_DOCUMENT CONTAINS 'gore-tex' AND LIKE '%jacket%';\n\n-- Complex nested conditions with parentheses\nSELECT id FROM products\nWHERE_DOCUMENT (CONTAINS 'waterproof' OR CONTAINS 'windproof')\n              AND LIKE '%outdoor%';\n\n-- Real-world example: Find bank-related documents\nSELECT document, metadata.object_name FROM transactions\nWHERE_DOCUMENT CONTAINS 'BofA' OR CONTAINS 'Bank of America' OR LIKE '%Wells Fargo%';\n\n-- Exclude documents with specific text\nSELECT id FROM products\nWHERE_DOCUMENT NOT CONTAINS 'deprecated';\n\n-- Exclude multi-word phrases\nSELECT id FROM products\nWHERE_DOCUMENT NOT LIKE '%do not use%';\n\n-- Match email patterns with REGEX\nSELECT id FROM contacts\nWHERE_DOCUMENT REGEX '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}';\n\n-- Case-insensitive matching with REGEX\nSELECT id FROM products\nWHERE_DOCUMENT REGEX '(?i)python';  -- Matches PYTHON, python, Python, etc.\n\n-- Exclude documents matching patterns\nSELECT id FROM documents\nWHERE_DOCUMENT NOT REGEX '\\d{3}-\\d{2}-\\d{4}';  -- Exclude SSN patterns\n</code></pre> <p>Case-sensitive matching</p> <p>Text operators (<code>CONTAINS</code>, <code>LIKE</code>, <code>REGEX</code>) are case-sensitive by default. For example:</p> <ul> <li><code>WHERE_DOCUMENT CONTAINS 'BofA'</code> will NOT match \"bofa\" or \"BOFA\"</li> <li><code>WHERE_DOCUMENT LIKE '%urgent%'</code> will NOT match \"Urgent\" or \"URGENT\"</li> </ul> <p>Workarounds:</p> <ul> <li>Use OR for multiple cases: <code>WHERE_DOCUMENT CONTAINS 'BofA' OR CONTAINS 'bofa' OR CONTAINS 'BOFA'</code></li> <li>Use REGEX with (?i) flag: <code>WHERE_DOCUMENT REGEX '(?i)bofa'</code> (matches BofA, bofa, BOFA, etc.)</li> </ul> <p>Pattern syntax</p> <ul> <li><code>LIKE</code> only supports the <code>%text%</code> shape (exactly two <code>%</code> wildcards at start and end, no <code>_</code> wildcard or mid-string <code>%</code>). Example: <code>WHERE_DOCUMENT LIKE '%gore-tex%'</code></li> <li>For complex patterns, use <code>REGEX</code>: <code>WHERE_DOCUMENT REGEX '.*gore.*tex.*'</code></li> </ul> <p>Schema context</p> <p>Document predicates operate on the <code>document</code> column, which stores the natural language product description in our example collection.</p> <p>Watch out</p> <p><code>WHERE</code> and <code>WHERE_DOCUMENT</code> are independent.  Specify both if you need both metadata and document filtering.</p> <ul> <li> Need Help?   Check the troubleshooting guide for fixes to the most common ChromaSQL hiccups.</li> </ul>"},{"location":"using-chromasql/tutorial/limitations/","title":"Current Limitations of ChromaSQL","text":"<ul> <li>Joins / multi-collection SQL.  Execute separate queries if you need to   merge results from multiple collections.</li> <li>Aggregations / GROUP BY.  Fetch the rows and aggregate in Python.</li> <li>Streaming or async execution.  The executor currently collects results   eagerly.  Wrap it yourself if you need incremental delivery.</li> <li>Custom arithmetic in ORDER BY.  Only <code>distance</code>, <code>id</code>, and metadata paths   are supported today.  Blend scores (e.g. <code>0.8 * SIM_SCORE + \u2026</code>) in your own   post-processing if you need that behaviour.</li> </ul> <p>If your workload depends on these gaps, we suggest that you build the missing behaviour in your application layer and follow the project changelog for roadmap updates.</p>"},{"location":"using-chromasql/tutorial/reranking-batching/","title":"Combine Batching, Reranking, and Filters","text":""},{"location":"using-chromasql/tutorial/reranking-batching/#add-rerank-hints-to-a-query","title":"Add Rerank Hints to a Query","text":"<p><pre><code>SELECT id, distance\nFROM products\nUSING EMBEDDING (TEXT 'graphite pencil')\nRERANK BY MMR(lambda = 0.4, candidates = 50)\nTOPK 10;\n</code></pre> * MMR (Maximal Marginal Relevance) is a popular diversification strategy. * The <code>RERANK</code> clause adds lambda and candidate values to the query plan metadata.</p>"},{"location":"using-chromasql/tutorial/reranking-batching/#full-example-with-batching-filters-and-reranking","title":"Full Example with Batching, Filters, and Reranking","text":"<p><pre><code>SELECT id, distance, metadata.brand\nFROM products\nUSING EMBEDDING BATCH (\n  TEXT 'trail running shoe',\n  TEXT 'lightweight hiking shoe'\n)\nWHERE metadata.gender IN ('men', 'unisex')\nWHERE_DOCUMENT LIKE '%gore-tex%'\nSIMILARITY COSINE\nTOPK 15\nRERANK BY MMR(lambda = 0.3, candidates = 60)\nORDER BY distance ASC\nLIMIT 10;\n</code></pre> This combines all supported clauses:</p> <ul> <li>Batch execution with two textual queries.</li> <li>Metadata + document filters.</li> <li>Similarity change, top-k, rerank hint, and pagination.</li> <li>Projection includes a nested metadata field.</li> </ul> <p>Schema context</p> <p><code>metadata.gender</code> and <code>metadata.brand</code> are additional metadata keys in the sample <code>products</code> schema.  Adjust the names to match your own domain.</p> <p>Clause order matters</p> <p>Keep the clauses in the order shown above.  Placing <code>WHERE_DOCUMENT</code> before <code>WHERE</code>, or rerank hints before <code>TOPK</code>, will raise parser errors.</p> <ul> <li> Need Help?   Check the troubleshooting guide for fixes to the most common ChromaSQL hiccups.</li> </ul>"},{"location":"using-chromasql/tutorial/setup/","title":"ChromaSQL Tutorial","text":"<p>Welcome! This guide shows you every clause the ChromaSQL DSL currently supports, why you might use it, and a few common pitfalls to avoid.  Follow it sequentially \u2013 the later sections build on the earlier ones.</p> <p>Tip</p> <p>ChromaSQL is read-only.  It queries ChromaDB collections but does not create, mutate, or delete data.</p>"},{"location":"using-chromasql/tutorial/setup/#demo-collection-schema","title":"Demo Collection Schema","text":"<p>To keep the examples concrete we will query an imaginary <code>products</code> collection. ChromaSQL operates on collections, so think of this as one table whose rows were previously ingested into ChromaDB.</p> <p>Core columns (ChromaSQL defaults)</p> <ul> <li><code>id</code>: Stable identifier for each row. Present in every collection.</li> <li><code>document</code>: The natural-language payload that was embedded (plain text).</li> <li><code>embedding</code>: The stored vector. Only returned when explicitly requested.</li> <li><code>metadata</code>: JSON object with user-defined attributes (keys vary by dataset).</li> </ul> <p>These four columns exist regardless of the domain you model\u2014you will see them in every example and in real queries, even if you never project or filter by all of them.</p> <p>Sample metadata keys for this tutorial (domain-specific)</p> <ul> <li><code>metadata.category</code> (string): Product category (e.g. <code>outerwear</code>).</li> <li><code>metadata.tags</code> (list of strings): Lightweight tags, such as <code>[\"waterproof\"]</code>.</li> <li><code>metadata.price</code> (number): Price in USD.</li> <li><code>metadata.gender</code> (string): Target audience (<code>men</code>, <code>women</code>, <code>unisex</code>).</li> <li><code>metadata.brand</code> (string): Brand name.</li> <li><code>metadata.model</code> (string): Internal classifier used in routing examples later on.</li> </ul> <p>Use-case specific metadata</p> <p>When an example introduces an additional key (for example <code>metadata.system</code> in the reranking section or <code>metadata.fieldname</code> in routing examples), it represents a hypothetical field that exists in this sample schema for illustration. </p> <p>Adjust the field names to match the metadata that lives in your own collections.</p> <ul> <li> Need Help?   Check the troubleshooting guide for fixes to the most common ChromaSQL hiccups.</li> </ul>"},{"location":"using-chromasql/tutorial/troubleshooting/","title":"Troubleshooting and Misconceptions","text":"Symptom Likely cause <code>ChromaSQLParseError: Unexpected token</code> Typo in your query, or clause order incorrect (e.g. <code>WHERE_DOCUMENT</code> before <code>WHERE</code>). <code>ChromaSQLPlanningError: TOPK can only be used with EMBEDDING queries</code> You forgot the <code>USING EMBEDDING</code> clause. Distances missing in results You ran a filter-only query or dropped <code>distance</code> from the projection. Batch query returns unexpected duplicates <code>TOPK</code> applies per batch item; results may contain duplicates across batch items. Rerank hint not affecting results <code>RERANK</code> clauses add metadata to the query plan for downstream processing. <p>If you bump into behaviour that feels surprising or want to propose a language extension, check out <code>CONTRIBUTING.md</code> for instructions on how to get involved.</p> <p>Check clause order first</p> <p>Most parser errors come from clauses being out of order.  Compare your query to the examples earlier in the tutorial before digging into deeper fixes.</p> <ul> <li> Still Stuck?   File a GitHub issue with the query and executor context if you run into a reproducible bug.</li> </ul>"},{"location":"using-chromasql/tutorial/vector-search/","title":"Run Vector Searches","text":""},{"location":"using-chromasql/tutorial/vector-search/#embed-text-on-the-fly","title":"Embed Text on the Fly","text":"<p><pre><code>SELECT id, distance, document\nFROM products\nUSING EMBEDDING (TEXT 'lightweight waterproof jacket')\nTOPK 5;\n</code></pre> * <code>TOPK</code> defaults to 10.  Only valid with vector queries. * Provide a custom model per query with <code>MODEL 'text-embedding-3-large'</code>.</p> <p>Swap embedding models per query</p> <p>Override the default embedding model with the <code>MODEL</code> clause when you need provider-specific encoders for an individual request.</p>"},{"location":"using-chromasql/tutorial/vector-search/#use-a-precomputed-vector","title":"Use a Precomputed Vector","text":"<p><pre><code>SELECT id, distance\nFROM products\nUSING EMBEDDING (VECTOR [0.12, -0.33, ...])\nTOPK 10;\n</code></pre> * Handy in tests or when you already cached embeddings on the client side.</p> <p>Great for benchmarks</p> <p>Providing your own vector keeps queries deterministic, which is useful when you want reproducible tests or to compare executor behaviour.</p>"},{"location":"using-chromasql/tutorial/vector-search/#batch-multiple-queries","title":"Batch Multiple Queries","text":"<p><pre><code>SELECT id, distance\nFROM products\nUSING EMBEDDING BATCH (\n  TEXT 'lightweight waterproof jacket',\n  VECTOR [0.05, 0.02, ...]\n)\nTOPK 5;\n</code></pre> * Each item in the batch is queried individually and post-processed with the   same projection / filters.</p> <p>Embed function required</p> <p>If you supply <code>TEXT</code> entries, pass an embed function to the executor.  If you skip it, you will see <code>ChromaSQLExecutionError</code>.</p> <p>TOPK applies per batch item</p> <p><code>TOPK</code> limits results per batch entry.  Deduplicate in post-processing if you need a global top-k.</p>"},{"location":"using-chromasql/tutorial/vector-search/#choose-a-similarity-metric","title":"Choose a Similarity Metric","text":"<p><pre><code>SELECT id, distance\nFROM products\nUSING EMBEDDING (TEXT 'soft shell jacket')\nSIMILARITY L2;\n</code></pre> * <code>COSINE</code> is the default; accepted values: <code>COSINE</code>, <code>L2</code>, <code>IP</code>. * The clause is a hint.  Ensure your Chroma collection was created with the   corresponding metric for consistent results.</p> <p>Match your collection metric</p> <p>Chroma stores vectors with a fixed distance metric.  If you hint <code>L2</code> but the collection was created with cosine, your results will be inconsistent.</p>"},{"location":"using-chromasql/tutorial/vector-search/#order-and-paginate-results","title":"Order and Paginate Results","text":"<p><pre><code>SELECT id, distance, metadata.price\nFROM products\nUSING EMBEDDING (TEXT 'down jacket')\nORDER BY distance ASC, metadata.price DESC\nLIMIT 20 OFFSET 10;\n</code></pre> * Vector queries automatically default to <code>ORDER BY distance ASC</code>. * Filter-only queries cannot order by <code>distance</code>.</p> <p>Note</p> <p><code>LIMIT</code> and <code>OFFSET</code> act after retrieval.  The executor asks for enough rows to respect <code>TOPK</code> and then trims locally.</p>"},{"location":"using-chromasql/tutorial/vector-search/#apply-score-thresholds","title":"Apply Score Thresholds","text":"<p><pre><code>SELECT id, distance\nFROM products\nUSING EMBEDDING (TEXT 'rain poncho')\nWITH SCORE THRESHOLD 0.15;\n</code></pre> * Discards results whose distance is greater than the threshold after the   ChromaSQL response is received.</p> <p>Tune thresholds against real data</p> <p>Distance values vary with the embedding model and metric.  Calibrate the threshold using real query logs so you do not accidentally hide relevant matches.</p> <ul> <li> Need Help?   Check the troubleshooting guide for fixes to the most common ChromaSQL hiccups.</li> </ul>"},{"location":"using-csql-llm/chromasql-prompt/","title":"Prompt Template for ChromaSQL","text":"<p>Embed this prompt when you want an agent or LLM to produce ChromaSQL statements that execute cleanly against ChromaDB collections. It captures the guardrails our runtime expects such as supported clause order, filtering rules, and multi-collection constraints.</p> <pre><code>## Core Facts\n- Read-only DSL: ChromaSQL issues `SELECT`/`EXPLAIN` queries; it never mutates data.\n- Single collection per query: There are no joins. To span models, filter on the discriminator metadata key and run one ChromaSQL statement at a time.\n- Every collection stores `id`, `document`, `embedding`, `metadata`, and query-time `distance`. Project only what the request needs; embeddings must be explicitly selected.\n- Use dotted paths for metadata: `metadata.model_name`, `metadata.category`, etc. Alias with `AS` when helpful.\n- Clause order:\n  `SELECT \u2026 FROM \u2026 [USING EMBEDDING (\u2026)] [WHERE \u2026] [SIMILARITY \u2026] [WITH SCORE THRESHOLD \u2026] [RERANK \u2026] [ORDER BY \u2026] [LIMIT \u2026 [OFFSET \u2026]];`\n  `EXPLAIN` precedes the `SELECT`.\n  Note: `USING EMBEDDING` always requires parentheses around TEXT/VECTOR/BATCH.\n\n## Filtering\n- Use `WHERE` to filter on metadata OR document fields. Combine predicates with `AND` / `OR` (wrap complex logic in parentheses).\n- **Metadata filtering:** Use dotted paths like `metadata.category = 'finance'`. Supported operators: `=`, `!=`, `&lt;`, `&lt;=`, `&gt;`, `&gt;=`, `IN`, `NOT IN`, `BETWEEN`.\n- **Document filtering (text matching):** ChromaSQL supports the following operators for full-text search on the `document` field:\n  - `CONTAINS 'text'` - Case-sensitive substring matching\n  - `NOT CONTAINS 'text'` - Excludes documents containing the text\n  - `LIKE '%pattern%'` - Substring matching with strict `%value%` format (exactly two % signs)\n  - `NOT LIKE '%pattern%'` - Excludes documents matching the pattern\n  - `REGEX 'pattern'` - Regular expression matching (supports full regex syntax)\n  - `NOT REGEX 'pattern'` - Excludes documents matching the regex\n- **CRITICAL:** Text operators (`CONTAINS`, `LIKE`, `REGEX`) only work on `document`, NOT on metadata (ChromaDB limitation). For metadata, use exact matches or comparisons.\n- **CRITICAL:** Different filter types (metadata vs. document) can ONLY be combined with `AND`, not `OR`. Within each type, use `OR` freely. ChromaDB limitation.\n  - **Operator precedence:** AND binds tighter than OR. Always use parentheses to group document OR expressions before combining with metadata filters.\n  - \u2705 VALID: `WHERE metadata.x = 'a' AND document CONTAINS 'b'`\n  - \u2705 VALID: `WHERE (metadata.x = 'a' OR metadata.y = 'b') AND document CONTAINS 'c'`\n  - \u2705 VALID: `WHERE metadata.package != '$TMP' AND (document CONTAINS 'check' OR document CONTAINS 'extract')`\n  - \u274c INVALID: `WHERE metadata.x = 'a' OR document CONTAINS 'b'`\n  - \u274c INVALID: `WHERE document CONTAINS 'a' OR document CONTAINS 'b' AND metadata.x = 'c'` -- AND binds tighter, creates OR between filter types\n- Examples:\n  - `WHERE metadata.category = 'finance' AND metadata.amount &gt; 1000`\n  - `WHERE document CONTAINS 'oauth' OR document CONTAINS 'authentication'`\n  - `WHERE document NOT CONTAINS 'deprecated'`  -- Exclude deprecated docs\n  - `WHERE document LIKE '%positive pay%'`  -- Multi-word phrase (space is literal)\n  - `WHERE document LIKE '%Bank of America%'`  -- Three-word phrase\n  - `WHERE document LIKE '%US_POSIPAY%'`  -- Underscore is treated as literal character\n  - `WHERE document NOT LIKE '%test%'`  -- Exclude test documents\n  - `WHERE document REGEX '[a-z]+@[a-z]+\\\\.com'`  -- Email pattern matching\n  - `WHERE document NOT REGEX '\\\\d{3}-\\\\d{2}-\\\\d{4}'`  -- Exclude SSNs\n  - `WHERE (document CONTAINS 'vendor' AND document LIKE '%payment%') OR document CONTAINS 'invoice'`\n  - `WHERE metadata.status = 'active' AND document NOT CONTAINS 'archived'`\n  - `WHERE metadata.package != '$TMP' AND ((document CONTAINS 'check' AND document CONTAINS 'extract') OR document CONTAINS 'RFCHKE00')`  -- Complex: metadata filter AND document OR expression (use parentheses!)\n\n## Vector Search\n- Add `USING EMBEDDING (TEXT '...')` for similarity search. The parentheses around TEXT are REQUIRED.\n- For batch queries (multiple search terms), use `USING EMBEDDING BATCH (TEXT '...', TEXT '...', ...)`\n- Examples:\n  - `USING EMBEDDING (TEXT 'positive pay processing')`\n  - `USING EMBEDDING (TEXT 'vendor invoice reconciliation')`\n  - `USING EMBEDDING BATCH (TEXT 'vendor invoice', TEXT 'payment receipt', TEXT 'purchase order')`\n- Always add `TOPK n` with embedding queries; the default is 10.\n- Change the metric with `SIMILARITY COSINE | L2 | IP`. Omit to keep the collection default.\n- Optional `WITH SCORE THRESHOLD x` discards rows whose distance exceeds `x`.\n- `RERANK BY MMR(lambda = \u2026, candidates = \u2026)` adds reranking metadata to the query plan.\n\n## Sorting &amp; Pagination\n- `ORDER BY` supports `distance`, `id`, or metadata paths. Vector queries sort by `distance ASC` by default.\n- Use `LIMIT n` and optional `OFFSET m` to paginate after retrieval. These operate on the merged result set.\n\n## Filter-Only Retrieval\n- Omitting `USING EMBEDDING` yields a metadata-only lookup (`collection.get`). `distance` cannot be selected or ordered in this mode.\n\n## Diagnostics\n- `EXPLAIN` before `SELECT` returns the planned request without hitting ChromaDB. \n\n## Limitations &amp; Pitfalls\n- No DML, DDL, joins, aggregations, window functions, or arithmetic expressions in `ORDER BY`.\n- **Text search operators** (`LIKE`, `CONTAINS`, `REGEX`) **only work on `document` field**, not on metadata. ChromaDB limitation: metadata filters don't support substring/pattern matching. Use `WHERE document LIKE '%value%'` or `WHERE document CONTAINS 'text'` for text search. For metadata, use exact matches (`=`, `IN`) or comparisons (`&lt;`, `&gt;`, `BETWEEN`).\n- **LIKE pattern restrictions**: `LIKE` requires patterns in the form `'%value%'` (literal string with exactly two `%` wildcards at start and end). Underscores are treated as literal characters (not wildcards).\n  - \u2705 VALID: `LIKE '%oauth%'`, `LIKE '%positive pay%'`, `LIKE '%Bank of America%'`, `LIKE '%US_POSIPAY%'` (underscore is literal)\n  - \u274c INVALID: `LIKE '%positive%pay%'` (extra % in middle), `LIKE '%oauth'` (missing ending %), `LIKE 'oauth%'` (missing starting %)\n  - For multi-word searches, include the entire phrase: `'%positive pay%'` NOT `'%positive%pay%'`\n  - For searching multiple separate terms anywhere in document: `WHERE document LIKE '%term1%' AND document LIKE '%term2%'`\n- **REGEX patterns**: Use standard regex syntax. `REGEX` supports full regular expression patterns:\n  - Email: `REGEX '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}'`\n  - Phone: `REGEX '\\\\d{3}-\\\\d{4}'`\n  - Case-insensitive: `REGEX '(?i)python'` (matches PYTHON, python, Python)\n  - Word boundaries and other regex features are supported\n- **Case-sensitive matching**: All text operators (`CONTAINS`, `LIKE`, `REGEX`) are case-sensitive by default. `WHERE document CONTAINS 'BofA'` will NOT match \"bofa\" or \"BOFA\". To query case-insensitively:\n  - Use OR for multiple variants: `WHERE document CONTAINS 'BofA' OR document CONTAINS 'bofa'`\n  - Use REGEX with (?i) flag: `WHERE document REGEX '(?i)bofa'` (matches BofA, bofa, BOFA, etc.)\n- **Mixed int/float comparisons**: ChromaDB may coerce types when comparing integer metadata values with float boundaries. For reliable results, use integer boundaries with integer metadata, or ensure float boundaries clearly exclude/include values (e.g., use `&gt;= 1499` instead of `&gt;= 1500.5` when metadata is `1500`).\n- Batch queries apply `TOPK` per batch item; results may contain duplicates across batch items.\n- `RERANK` clauses add metadata to the query plan for downstream processing.\n</code></pre> <ul> <li> Have Ideas to Improve the Prompt? Submit a Pull Request.</li> </ul>"},{"location":"using-csql-py/","title":"ChromaSQL Python Package Overview","text":"<p>The ChromaSQL Python package wraps the query language with helpers that let you parse, plan, and execute requests against ChromaDB collections. It also includes utilities for running the same query across multiple collections with smart routing and result merging.</p>"},{"location":"using-csql-py/#core-capabilities","title":"Core Capabilities","text":"<ul> <li>Parsing \u2013 Convert SQL-flavoured strings into typed AST nodes with   <code>chromasql.parse</code>.</li> <li>Planning \u2013 Validate queries and produce executable plans using   <code>chromasql.build_plan</code> or <code>chromasql.plan_to_dict</code>.</li> <li>Execution \u2013 Run plans against a Chroma collection with automatic handling   of vector queries, metadata-only lookups, ordering, and pagination.</li> <li>Embedding Integration \u2013 Supply inline text or literal vectors; the engine   calls your embed function on demand for text entries and supports batch   queries.</li> <li>Explain Output \u2013 Inspect internal planner decisions without hitting   ChromaDB by turning plans into dictionaries.</li> </ul>"},{"location":"using-csql-py/#multi-collection-support","title":"Multi-Collection Support","text":"<ul> <li>Routing Abstractions \u2013 Use <code>CollectionRouter</code> protocols to decide which   collections to hit based on metadata filters or custom logic.</li> <li>Async Execution \u2013 The <code>execute_multi_collection</code> helper fans a query out   across the routed collections, executes them concurrently, and merges the   results.</li> <li>Adapters \u2013 Drop-in adapters wrap common async ChromaDB clients and handle   collection caching, error handling, and retries.</li> <li>Extensible Strategies \u2013 Build bespoke routers for tenant isolation, model   separation, or any discriminator field present in your metadata.</li> </ul>"},{"location":"using-csql-py/#when-to-use-the-package","title":"When to Use the Package","text":"<ul> <li>You need a reliable bridge between ChromaSQL and ChromaDB\u2019s   Python client.</li> <li>You want to expose ChromaSQL as part of an API, agent, or orchestration layer   without writing your own planner or executor.</li> <li>Your deployment queries multiple collections and requires predictable routing   rules, graceful fallbacks, and merged result sets.</li> </ul>"},{"location":"using-csql-py/examples/","title":"Examples","text":"<p>The best way to explore ChromaSQL is through practical snippets. These examples assume the demo <code>products</code> collection described in the ChromaSQL's tutorial series. Before trying them out, make sure you have:</p> <ul> <li>A <code>ChromaDB</code> collection handle (sync or async) assigned to <code>my_collection</code>.</li> <li>An embedding function <code>my_embed_fn</code> if you plan to execute text-based vector   queries.</li> <li>The <code>chromasql</code> package installed and imported as shown below.</li> </ul>"},{"location":"using-csql-py/examples/#vector-similarity-search","title":"Vector Similarity Search","text":"<pre><code>from chromasql import parse, build_plan, execute_plan\n\nquery = parse(\"\"\"\n    SELECT id, distance, document\n    FROM products\n    USING EMBEDDING (TEXT 'lightweight waterproof jacket')\n    TOPK 3;\n\"\"\")\n\nplan = build_plan(query)\nresult = execute_plan(plan, collection=my_collection, embed_fn=my_embed_fn)\n\nfor row in result.rows:\n    print(row[\"id\"], row[\"distance\"])\n</code></pre> <p>Batch queries follow the same pattern; each entry is evaluated independently:</p> <pre><code>query = parse(\"\"\"\n    SELECT id, distance\n    FROM products\n    USING EMBEDDING BATCH (\n        TEXT 'lightweight waterproof jacket',\n        VECTOR [0.05, 0.02, -0.17]\n    )\n    TOPK 5;\n\"\"\")\n</code></pre> <p>Change the embedding model per request with <code>MODEL 'text-embedding-3-large'</code> inside the <code>USING EMBEDDING</code> clause when you need provider-specific encoders.</p>"},{"location":"using-csql-py/examples/#filter-only-retrieval","title":"Filter-Only Retrieval","text":"<pre><code>query = parse(\"\"\"\n    SELECT id, metadata\n    FROM products\n    WHERE metadata.category = 'accessories'\n    ORDER BY metadata.price ASC\n    LIMIT 5;\n\"\"\")\n\nplan = build_plan(query)\nresult = execute_plan(plan, collection=my_collection)\n</code></pre> <p>Filter-only queries run <code>collection.get</code> under the hood. You can still project <code>embedding</code> explicitly, but <code>distance</code> is unavailable and cannot appear in <code>ORDER BY</code>.</p>"},{"location":"using-csql-py/examples/#explain-output","title":"Explain Output","text":"<pre><code>from chromasql import plan_to_dict\n\nplan = build_plan(parse(\"\"\"\n    SELECT id, distance\n    FROM products\n    USING EMBEDDING (VECTOR [0.1, 0.2, 0.3])\n    LIMIT 5;\n\"\"\"))\n\nprint(plan_to_dict(plan))\n</code></pre> <p>Typical output includes the execution mode, projection, filters, and embedding payload:</p> <pre><code>plan_dict = plan_to_dict(plan)\nprint(plan_dict[\"execution_mode\"])  # \"vector\"\nprint(plan_dict[\"includes\"])        # [\"id\", \"distance\"]\nprint(plan_dict[\"vector\"][\"value\"]) # your literal vector\n</code></pre>"},{"location":"using-csql-py/examples/#multi-collection-query-via-adapter","title":"Multi-Collection Query via Adapter","text":"<p>Jump to the multi-collection examples for full async walkthroughs that pair routers, adapters, and concurrency patterns.</p> <p>Additional real-world scenarios are covered in <code>tests/chromasql</code>, which double as executable documentation.</p> <ul> <li> Need Help? Open a GitHub issue with the steps to reproduce and we\u2019ll help you debug it.</li> </ul>"},{"location":"using-csql-py/getting-started/","title":"Getting Started","text":"<p>This guide walks through installing ChromaSQL, executing your first query, and understanding the core workflow.</p>"},{"location":"using-csql-py/getting-started/#installation","title":"Installation","text":"<pre><code>pip install chromasql\n</code></pre> <p>If you are working from the monorepo, you can build and install a wheel with:</p> <pre><code>poetry run python -m build --wheel\npip install dist/chromasql-*.whl\n</code></pre>"},{"location":"using-csql-py/getting-started/#basic-usage","title":"Basic Usage","text":"<pre><code>from chromasql import parse, build_plan, execute_plan\n\nquery = parse(\"\"\"\n    SELECT id, document\n    FROM products\n    USING EMBEDDING (TEXT 'mesh office chair')\n    TOPK 5;\n\"\"\")\n\nplan = build_plan(query)\nresult = execute_plan(plan, collection=my_chroma_collection, embed_fn=my_embed_fn)\n\nfor row in result.rows:\n    print(row[\"id\"], row[\"document\"])\n</code></pre>"},{"location":"using-csql-py/getting-started/#required-components","title":"Required Components","text":"<ul> <li>Collection \u2013 a ChromaDB collection handle (sync or async).</li> <li>embed_fn \u2013 callable that turns text into embeddings when <code>TEXT</code> clauses are   used. Literal vectors do not need this.</li> </ul>"},{"location":"using-csql-py/getting-started/#explaining-plans","title":"Explaining Plans","text":"<p>Use <code>plan_to_dict</code> to inspect how a query will execute without hitting the database:</p> <pre><code>from chromasql import plan_to_dict\nplan_dict = plan_to_dict(plan)\nprint(plan_dict)\n</code></pre> <p>The explain output mirrors the arguments passed to <code>collection.query</code> or <code>collection.get</code>.</p> <ul> <li> Need Help? Open a GitHub issue with the steps to reproduce and we\u2019ll help you debug it.</li> </ul>"},{"location":"using-csql-py/multi-collection/EXAMPLES/","title":"ChromaSQL Multi-Collection Examples","text":"<p>This document provides practical examples of using ChromaSQL with multi-collection setups. These patterns are useful when you have data partitioned across multiple ChromaDB collections.</p>"},{"location":"using-csql-py/multi-collection/EXAMPLES/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Basic Multi-Collection Query</li> <li>Model-Based Routing (Most Common)</li> <li>Custom Routing Strategy</li> <li>Fallback Behavior</li> <li>Integration with AsyncMultiCollectionQueryClient</li> <li>Error Handling and Resilience</li> </ol>"},{"location":"using-csql-py/multi-collection/EXAMPLES/#basic-multi-collection-query","title":"Basic Multi-Collection Query","text":"<p>The simplest way to query multiple collections is to provide a static list:</p> <pre><code>import asyncio\nfrom pathlib import Path\nfrom chromasql.multi_collection import execute_multi_collection, CollectionRouter\nfrom chromasql.adapters import SimpleAsyncClientAdapter\nimport chromadb\n\n# Simple router that queries specific collections\nclass StaticRouter(CollectionRouter):\n    def __init__(self, collections):\n        self.collections = collections\n\n    def route(self, query):\n        return self.collections\n\nasync def main():\n    # Connect to ChromaDB\n    client = await chromadb.AsyncHttpClient(host=\"localhost\", port=8000)\n\n    # Create adapter\n    adapter = SimpleAsyncClientAdapter(\n        client=client,\n        collection_names=[\"collection_1\", \"collection_2\", \"collection_3\"],\n    )\n\n    # Execute query across specific collections\n    router = StaticRouter([\"collection_1\", \"collection_2\"])\n\n    result = await execute_multi_collection(\n        query_str=\"\"\"\n            SELECT id, distance, document\n            FROM demo\n            USING EMBEDDING (VECTOR [0.1, 0.2, 0.3])\n            TOPK 10;\n        \"\"\",\n        router=router,\n        collection_provider=adapter,\n    )\n\n    # Results are merged and sorted by distance\n    for row in result.rows:\n        print(f\"{row['id']}: {row['distance']}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"using-csql-py/multi-collection/EXAMPLES/#model-based-routing-most-common","title":"Model-Based Routing (Most Common)","text":"<p>Route queries based on <code>metadata.model</code> filter using your existing query config:</p> <pre><code>import asyncio\nfrom pathlib import Path\nfrom chromasql.adapters import MetadataFieldRouter\nfrom chromasql.multi_collection import execute_multi_collection\nfrom idxr.query_lib.async_multi_collection_adapter import AsyncMultiCollectionAdapter\nfrom idxr.vectorize_lib.query_client import AsyncMultiCollectionQueryClient\nfrom idxr.vectorize_lib.query_config import load_query_config\n\nasync def query_by_model(query_str: str, embed_fn):\n    \"\"\"Execute a ChromaSQL query with model-based routing.\"\"\"\n\n    # Load query config (generated by vectorize_lib)\n    config = load_query_config(Path(\"output/query_config.json\"))\n\n    # Initialize multi-collection client\n    client = AsyncMultiCollectionQueryClient(\n        config_path=Path(\"output/query_config.json\"),\n        client_type=\"cloud\",\n        cloud_api_key=\"your-api-key\",\n        cloud_tenant=\"your-tenant\",\n        cloud_database=\"your-database\",\n    )\n    await client.connect()\n\n    try:\n        # Create adapters\n        adapter = AsyncMultiCollectionAdapter(client)\n        router = MetadataFieldRouter(\n            query_config=config,\n            field_path=(\"model\",),  # Route based on metadata.model\n            fallback_to_all=True,   # Query all 37 collections if not specified\n        )\n\n        # Execute query\n        result = await execute_multi_collection(\n            query_str=query_str,\n            router=router,\n            collection_provider=adapter,\n            embed_fn=embed_fn,\n        )\n\n        return result\n\n    finally:\n        await client.close()\n\n# Example usage\nasync def main():\n    def my_embed(text, model):\n        # Your embedding logic here\n        return [0.1, 0.2, 0.3] * 384  # Example 384-dim vector\n\n    # Query specific models - only queries collections containing Table/Field\n    result = await query_by_model(\n        query_str=\"\"\"\n            SELECT id, distance, metadata.model, document\n            FROM sap_data\n            WHERE metadata.model IN ('Table', 'Field')\n              AND metadata.environment = 'production'\n            USING EMBEDDING (TEXT 'SAP financial tables')\n            TOPK 20;\n        \"\"\",\n        embed_fn=my_embed,\n    )\n\n    print(f\"Found {len(result.rows)} results\")\n    for row in result.rows:\n        print(f\"  {row['id']} ({row['metadata.model']}): {row['distance']:.3f}\")\n\n    # Query without model filter - queries all 37 collections\n    result_all = await query_by_model(\n        query_str=\"\"\"\n            SELECT id, distance, document\n            FROM sap_data\n            WHERE metadata.environment = 'production'\n            USING EMBEDDING (TEXT 'configuration settings')\n            TOPK 10;\n        \"\"\",\n        embed_fn=my_embed,\n    )\n\n    print(f\"\\nQueried all collections, found {len(result_all.rows)} results\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"using-csql-py/multi-collection/EXAMPLES/#custom-routing-strategy","title":"Custom Routing Strategy","text":"<p>Implement custom routing logic for complex scenarios:</p> <pre><code>from typing import Optional, Sequence\nfrom chromasql.multi_collection import CollectionRouter\nfrom chromasql.analysis import extract_metadata_values\nfrom chromasql.ast import Query\n\nclass TenantAndRegionRouter(CollectionRouter):\n    \"\"\"Route based on both tenant and region metadata.\"\"\"\n\n    def __init__(self, collection_mapping: dict):\n        \"\"\"\n        collection_mapping example:\n        {\n            (\"tenant_123\", \"us-east\"): [\"shard_001\", \"shard_002\"],\n            (\"tenant_123\", \"eu-west\"): [\"shard_003\"],\n            (\"tenant_456\", \"us-east\"): [\"shard_004\"],\n        }\n        \"\"\"\n        self.collection_mapping = collection_mapping\n\n    def route(self, query: Query) -&gt; Optional[Sequence[str]]:\n        # Extract both discriminators\n        tenants = extract_metadata_values(query, field_path=(\"tenant_id\",))\n        regions = extract_metadata_values(query, field_path=(\"region\",))\n\n        if not tenants or not regions:\n            # If either is missing, query all collections\n            return None\n\n        # Find collections for all (tenant, region) pairs\n        collections = set()\n        for tenant in tenants:\n            for region in regions:\n                key = (tenant, region)\n                if key in self.collection_mapping:\n                    collections.update(self.collection_mapping[key])\n\n        return sorted(collections) if collections else None\n\n\n# Usage\nasync def main():\n    mapping = {\n        (\"tenant_123\", \"us-east\"): [\"shard_001\", \"shard_002\"],\n        (\"tenant_123\", \"eu-west\"): [\"shard_003\"],\n        (\"tenant_456\", \"us-east\"): [\"shard_004\"],\n    }\n\n    router = TenantAndRegionRouter(mapping)\n\n    # This will only query shard_001 and shard_002\n    result = await execute_multi_collection(\n        query_str=\"\"\"\n            SELECT id, distance\n            FROM data\n            WHERE metadata.tenant_id = 'tenant_123'\n              AND metadata.region = 'us-east'\n            USING EMBEDDING (TEXT 'search query')\n            TOPK 10;\n        \"\"\",\n        router=router,\n        collection_provider=adapter,\n        embed_fn=embed_fn,\n    )\n</code></pre>"},{"location":"using-csql-py/multi-collection/EXAMPLES/#fallback-behavior","title":"Fallback Behavior","text":"<p>Control what happens when discriminator fields are not filtered:</p> <pre><code>from chromasql.adapters import MetadataFieldRouter\n\n# Option 1: Fallback to all collections (recommended for most cases)\nrouter_with_fallback = MetadataFieldRouter(\n    query_config=config,\n    field_path=(\"model\",),\n    fallback_to_all=True,  # Default behavior\n)\n\n# This query doesn't filter on metadata.model, so it queries all collections\nresult = await execute_multi_collection(\n    query_str=\"\"\"\n        SELECT id FROM demo\n        WHERE metadata.status = 'active'\n        USING EMBEDDING (TEXT 'query')\n        TOPK 5;\n    \"\"\",\n    router=router_with_fallback,\n    collection_provider=adapter,\n    embed_fn=embed_fn,\n)\nprint(f\"Queried all collections, found {len(result.rows)} results\")\n\n\n# Option 2: Require discriminator field (strict mode)\nrouter_strict = MetadataFieldRouter(\n    query_config=config,\n    field_path=(\"model\",),\n    fallback_to_all=False,  # Raise error if not filtered\n)\n\ntry:\n    # This will raise ValueError because metadata.model is not filtered\n    result = await execute_multi_collection(\n        query_str=\"SELECT id FROM demo WHERE metadata.status = 'active';\",\n        router=router_strict,\n        collection_provider=adapter,\n    )\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n    # Output: \"Query must filter on metadata.model (fallback_to_all is disabled)\"\n</code></pre>"},{"location":"using-csql-py/multi-collection/EXAMPLES/#integration-with-asyncmulticollectionqueryclient","title":"Integration with AsyncMultiCollectionQueryClient","text":"<p>Seamlessly integrate ChromaSQL with your existing vectorize_lib infrastructure:</p> <pre><code>import asyncio\nfrom pathlib import Path\nfrom chromasql import parse, extract_metadata_values\nfrom chromasql.adapters import MetadataFieldRouter\nfrom chromasql.multi_collection import execute_multi_collection\nfrom idxr.query_lib.async_multi_collection_adapter import AsyncMultiCollectionAdapter\nfrom idxr.vectorize_lib.query_client import AsyncMultiCollectionQueryClient\nfrom idxr.vectorize_lib.query_config import load_query_config\n\nclass ChromaSQLQueryService:\n    \"\"\"Service that wraps ChromaSQL with your existing infrastructure.\"\"\"\n\n    def __init__(self, config_path: Path, **client_kwargs):\n        self.config_path = config_path\n        self.client_kwargs = client_kwargs\n        self.client = None\n        self.adapter = None\n        self.router = None\n        self.config = None\n\n    async def connect(self):\n        \"\"\"Initialize connections.\"\"\"\n        # Load config\n        self.config = load_query_config(self.config_path)\n\n        # Initialize client\n        self.client = AsyncMultiCollectionQueryClient(\n            config_path=self.config_path,\n            **self.client_kwargs,\n        )\n        await self.client.connect()\n\n        # Create adapters\n        self.adapter = AsyncMultiCollectionAdapter(self.client)\n        self.router = MetadataFieldRouter(\n            query_config=self.config,\n            field_path=(\"model\",),\n            fallback_to_all=True,\n        )\n\n    async def close(self):\n        \"\"\"Close connections.\"\"\"\n        if self.client:\n            await self.client.close()\n\n    async def query(self, sql: str, embed_fn):\n        \"\"\"Execute a ChromaSQL query.\"\"\"\n        return await execute_multi_collection(\n            query_str=sql,\n            router=self.router,\n            collection_provider=self.adapter,\n            embed_fn=embed_fn,\n        )\n\n    def preview_routing(self, sql: str):\n        \"\"\"Preview which collections would be queried (without executing).\"\"\"\n        query = parse(sql)\n        collections = self.router.route(query)\n\n        if collections is None:\n            all_collections = sorted(self.config[\"collection_to_models\"].keys())\n            return {\n                \"mode\": \"all\",\n                \"collections\": all_collections,\n                \"count\": len(all_collections),\n            }\n        else:\n            return {\n                \"mode\": \"targeted\",\n                \"collections\": list(collections),\n                \"count\": len(collections),\n            }\n\n    async def __aenter__(self):\n        await self.connect()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        await self.close()\n\n\n# Usage\nasync def main():\n    async with ChromaSQLQueryService(\n        config_path=Path(\"output/query_config.json\"),\n        client_type=\"cloud\",\n        cloud_api_key=\"your-api-key\",\n    ) as service:\n\n        # Preview routing\n        sql = \"\"\"\n            SELECT id, distance, document\n            FROM sap_data\n            WHERE metadata.model IN ('Table', 'Field')\n            USING EMBEDDING (TEXT 'financial tables')\n            TOPK 10;\n        \"\"\"\n\n        routing_info = service.preview_routing(sql)\n        print(f\"Will query {routing_info['count']} collection(s):\")\n        print(f\"  Mode: {routing_info['mode']}\")\n        print(f\"  Collections: {routing_info['collections'][:5]}...\")\n\n        # Execute query\n        def embed(text, model):\n            # Your embedding logic\n            return [0.1] * 384\n\n        result = await service.query(sql, embed_fn=embed)\n        print(f\"\\nFound {len(result.rows)} results\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"using-csql-py/multi-collection/EXAMPLES/#error-handling-and-resilience","title":"Error Handling and Resilience","text":"<p>Handle partial collection failures gracefully:</p> <pre><code>from chromasql.errors import ChromaSQLExecutionError\n\nasync def resilient_query(query_str: str, router, adapter, embed_fn):\n    \"\"\"Execute query with retry logic and fallback.\"\"\"\n\n    try:\n        result = await execute_multi_collection(\n            query_str=query_str,\n            router=router,\n            collection_provider=adapter,\n            embed_fn=embed_fn,\n        )\n\n        # Check if we got partial results\n        if result.raw.get(\"merged_from_collections\"):\n            total_collections = result.raw.get(\"total_collections_attempted\", 0)\n            successful = result.raw[\"merged_from_collections\"]\n\n            if successful &lt; total_collections:\n                print(f\"Warning: Only {successful}/{total_collections} collections responded\")\n\n        return result\n\n    except ChromaSQLExecutionError as e:\n        if \"All collection queries failed\" in str(e):\n            print(\"All collections failed - check your connection\")\n            # Fallback: try with a smaller subset\n            # Or: alert monitoring system\n            raise\n        else:\n            print(f\"Query error: {e}\")\n            raise\n\n\n# The multi-collection executor automatically handles partial failures:\n# - If some collections fail, results from successful collections are returned\n# - If ALL collections fail, ChromaSQLExecutionError is raised\n# - Individual collection errors are logged but don't fail the entire query\n\nasync def main():\n    result = await resilient_query(\n        query_str=\"SELECT id FROM demo USING EMBEDDING (TEXT 'test') TOPK 10;\",\n        router=router,\n        adapter=adapter,\n        embed_fn=embed_fn,\n    )\n\n    print(f\"Successfully retrieved {len(result.rows)} results\")\n</code></pre>"},{"location":"using-csql-py/multi-collection/EXAMPLES/#or-predicate-routing-union-behavior","title":"OR Predicate Routing (Union Behavior)","text":"<p>ChromaSQL uses union routing for OR predicates to ensure you never miss results:</p> <pre><code># Query with OR predicate\nresult = await execute_multi_collection(\n    query_str=\"\"\"\n        SELECT id, distance, document\n        FROM sap_data\n        WHERE metadata.model = 'Table' OR metadata.model = 'Field'\n        USING EMBEDDING (TEXT 'financial data')\n        TOPK 10;\n    \"\"\",\n    router=router,\n    collection_provider=adapter,\n    embed_fn=embed_fn,\n)\n\n# Router behavior:\n# 1. Extracts {'Table', 'Field'} from OR branches\n# 2. Maps to collections: Table \u2192 [coll_1, coll_2], Field \u2192 [coll_3, coll_4]\n# 3. Queries UNION: [coll_1, coll_2, coll_3, coll_4]\n# 4. Merges results and returns top 10 globally\n</code></pre>"},{"location":"using-csql-py/multi-collection/EXAMPLES/#important-or-behaviors","title":"Important OR Behaviors","text":"<p>\u2705 Union across multiple OR branches: <pre><code>-- Queries union of all three models\nWHERE metadata.model = 'Table'\n   OR metadata.model = 'Field'\n   OR metadata.model = 'View'\n</code></pre></p> <p>\u2705 Works with IN and OR combinations: <pre><code>-- Extracts {'A', 'B', 'C', 'D'}\nWHERE metadata.model IN ('A', 'B')\n   OR metadata.model IN ('C', 'D')\n</code></pre></p> <p>\u2705 Mixed OR (discriminator + other fields): <pre><code>-- Extracts {'Table'} only (has_sem not a routing field)\n-- Still queries all collections that contain 'Table'\nWHERE metadata.model = 'Table'\n   OR metadata.has_sem = FALSE\n</code></pre></p> <p>\u26a0\ufe0f OR with no discriminator field: <pre><code>-- No model values \u2192 falls back to ALL collections\nWHERE metadata.status = 'active'\n   OR metadata.has_sem = TRUE\n</code></pre></p>"},{"location":"using-csql-py/multi-collection/EXAMPLES/#why-union-routing","title":"Why Union Routing?","text":"<p>Union routing prevents under-routing - missing results because a collection wasn't queried:</p> <pre><code># Without union routing (BAD):\n# Query: WHERE model = 'Table' OR has_sem = FALSE\n# Router sees: model = 'Table'\n# Queries: Only collections with 'Table'\n# Problem: Misses records where has_sem = FALSE but model != 'Table'\n\n# With union routing (GOOD):\n# Query: WHERE model = 'Table' OR has_sem = FALSE\n# Router extracts: {'Table'}\n# Queries: All collections containing 'Table'\n# The full WHERE clause is still applied to each collection\n# No results are missed!\n</code></pre> <p>The key insight: The router determines which collections to query, but each collection receives the full WHERE clause. So even if <code>has_sem = FALSE</code> isn't a routing field, records matching that condition will be found in any queried collection.</p>"},{"location":"using-csql-py/multi-collection/EXAMPLES/#performance-tips","title":"Performance Tips","text":"<ol> <li> <p>Use <code>n_results_per_collection</code> for better recall: <pre><code>result = await execute_multi_collection(\n    query_str=\"SELECT id FROM demo USING EMBEDDING (TEXT 'test') TOPK 10;\",\n    router=router,\n    collection_provider=adapter,\n    embed_fn=embed_fn,\n    n_results_per_collection=50,  # Fetch 50 from each, return top 10 overall\n)\n</code></pre></p> </li> <li> <p>Filter aggressively in WHERE clause:</p> </li> <li>Include discriminator fields to reduce collections queried</li> <li>Add other filters to reduce data transfer</li> <li> <p>Use AND with discriminator fields when possible</p> </li> <li> <p>Monitor routing decisions: <pre><code>query = parse(your_sql)\ncollections = router.route(query)\nprint(f\"Querying {len(collections) if collections else 'all'} collection(s)\")\n</code></pre></p> </li> <li> <p>Use LIMIT judiciously:</p> </li> <li><code>LIMIT</code> is applied after merging results from all collections</li> <li>Each collection still returns <code>n_results</code> (or <code>n_results_per_collection</code>)</li> <li> <p>Consider using smaller <code>TOPK</code> instead of large <code>LIMIT</code></p> </li> <li> <p>Understand OR performance implications:</p> </li> <li>OR predicates with discriminator fields query union of collections</li> <li>OR with non-discriminator fields queries all collections</li> <li>Use AND when possible to narrow collection scope</li> </ol> <p>For more information, see: - CONTRIBUTING.md for architecture details - Build Your First Query for ChromaSQL syntax reference - chromasql/multi_collection.py for API documentation</p> <ul> <li> Need Help? Open a GitHub issue with the steps to reproduce and we\u2019ll help you debug it.</li> </ul>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/","title":"OR Predicate Routing: Edge Cases and Test Coverage","text":"<p>This document catalogs all edge cases for OR predicate routing in ChromaSQL's multi-collection system, ensuring comprehensive test coverage and documenting expected behavior.</p>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#overview","title":"Overview","text":"<p>ChromaSQL uses union routing for OR predicates: when a query contains <code>OR</code> predicates with discriminator field filters, the system extracts values from all branches and queries the union of collections.</p> <p>This prevents under-routing (missing results because a collection wasn't queried).</p>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#core-principle","title":"Core Principle","text":"<pre><code>WHERE metadata.model = 'A' OR metadata.model = 'B'\n\u2192 Extracts {'A', 'B'}\n\u2192 Routes to: union(collections_for_A, collections_for_B)\n</code></pre> <p>The router determines which collections to query, but each collection receives the full WHERE clause. Results are filtered by the complete predicate at query time.</p>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#edge-cases-tested","title":"Edge Cases Tested","text":""},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#1-simple-or-with-same-field","title":"1. \u2705 Simple OR with Same Field","text":"<p>Query: <pre><code>WHERE metadata.model = 'Table' OR metadata.model = 'Field'\n</code></pre></p> <p>Expected Behavior: - Extracts: <code>{'Table', 'Field'}</code> - Routes to: All collections containing 'Table' OR 'Field'</p> <p>Test: <code>test_extract_metadata_values_with_or_single_field</code></p>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#2-or-with-different-fields-triggers-fallback","title":"2. \u2705 OR with Different Fields (Triggers Fallback)","text":"<p>Query: <pre><code>WHERE metadata.model = 'Table' OR metadata.has_sem = FALSE\n</code></pre></p> <p>Expected Behavior: - Extracts: <code>None</code> (fallback to all collections) - Routes to: ALL collections - Why: The second OR branch (<code>has_sem = FALSE</code>) could match records in ANY collection, so we must query all to avoid under-routing</p> <p>Test: <code>test_extract_metadata_values_with_or_different_fields</code></p>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#3-or-with-in-clause","title":"3. \u2705 OR with IN Clause","text":"<p>Query: <pre><code>WHERE metadata.model IN ('Table', 'Field') OR metadata.model = 'View'\n</code></pre></p> <p>Expected Behavior: - Extracts: <code>{'Table', 'Field', 'View'}</code> - Routes to: Union of all three models' collections</p> <p>Test: <code>test_extract_metadata_values_with_or_in_clause</code></p>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#4-nested-or-predicates","title":"4. \u2705 Nested OR Predicates","text":"<p>Query: <pre><code>WHERE (metadata.model = 'Table' OR metadata.model = 'Field')\n      OR metadata.model = 'View'\n</code></pre></p> <p>Expected Behavior: - Extracts: <code>{'Table', 'Field', 'View'}</code> (flattens nested OR) - Routes to: Union of all three models' collections</p> <p>Test: <code>test_extract_metadata_values_with_nested_or</code></p>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#5-or-with-nested-and-users-specific-case","title":"5. \u2705 OR with Nested AND (User's Specific Case)","text":"<p>Query: <pre><code>WHERE metadata.model = 'Table'\n      OR (metadata.model = 'Field' AND metadata.fieldname = 'lang')\n</code></pre></p> <p>Expected Behavior: - Extracts: <code>{'Table', 'Field'}</code> (both models from OR branches) - Routes to: Collections for 'Table' + Collections for 'Field' - The <code>fieldname = 'lang'</code> filter is applied at query time in each collection</p> <p>Test: <code>test_extract_or_with_nested_and</code></p> <p>Why This Works: - The AND branch <code>(metadata.model = 'Field' AND metadata.fieldname = 'lang')</code> contains <code>model = 'Field'</code> - Extraction traverses the entire predicate tree, collecting all discriminator values - Collections for 'Field' receive the full WHERE clause and filter on <code>fieldname = 'lang'</code></p>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#6-multiple-or-branches-with-and","title":"6. \u2705 Multiple OR Branches with AND","text":"<p>Query: <pre><code>WHERE (metadata.model = 'Table' AND metadata.system = 'S4')\n      OR (metadata.model = 'Field' AND metadata.fieldname = 'lang')\n      OR (metadata.model = 'View' AND metadata.active = TRUE)\n</code></pre></p> <p>Expected Behavior: - Extracts: <code>{'Table', 'Field', 'View'}</code> - Routes to: Union of all three models' collections - Each collection gets the full WHERE clause and applies its branch's filters</p> <p>Test: <code>test_extract_complex_or_with_multiple_nested_ands</code></p>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#7-deeply-nested-orand-combinations","title":"7. \u2705 Deeply Nested OR/AND Combinations","text":"<p>Query: <pre><code>WHERE (\n    (metadata.model = 'Table' AND metadata.system = 'ECC')\n    OR (\n        metadata.model = 'Field'\n        AND (metadata.type = 'CHAR' OR metadata.type = 'NUMC')\n    )\n) OR metadata.model = 'View'\n</code></pre></p> <p>Expected Behavior: - Extracts: <code>{'Table', 'Field', 'View'}</code> - Routes to: Union of all three models' collections - Handles arbitrary nesting depth</p> <p>Test: <code>test_extract_deeply_nested_or_and</code></p>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#8-or-with-no-discriminator-field","title":"8. \u2705 OR with No Discriminator Field","text":"<p>Query: <pre><code>WHERE metadata.status = 'active' OR metadata.has_sem = TRUE\n</code></pre></p> <p>Expected Behavior: - Extracts: <code>None</code> (no discriminator values found) - Routes to: All collections (fallback mode)</p> <p>Test: <code>test_extract_metadata_values_or_with_no_target_field</code></p>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#9-or-with-only-some-branches-having-discriminator-triggers-fallback","title":"9. \u2705 OR with Only Some Branches Having Discriminator (Triggers Fallback)","text":"<p>Query: <pre><code>WHERE (metadata.status = 'active' AND metadata.year &gt; 2020)\n      OR metadata.model = 'Table'\n      OR (metadata.has_sem = TRUE AND metadata.env = 'prod')\n</code></pre></p> <p>Expected Behavior: - Extracts: <code>None</code> (fallback to all collections) - Routes to: ALL collections - Why: Branches 1 and 3 lack the discriminator field and could match records in any collection</p> <p>Test: <code>test_extract_or_with_only_one_branch_having_target_field</code></p>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#10-or-combining-in-and-and-clauses","title":"10. \u2705 OR Combining IN and AND Clauses","text":"<p>Query: <pre><code>WHERE metadata.model IN ('Table', 'View')\n      OR (metadata.model = 'Field' AND metadata.required = TRUE)\n      OR (metadata.model = 'Function' AND metadata.status = 'active')\n</code></pre></p> <p>Expected Behavior: - Extracts: <code>{'Table', 'View', 'Field', 'Function'}</code> - Routes to: Union of all four models' collections</p> <p>Test: <code>test_extract_or_with_in_and_nested_and</code></p>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#11-complex-andor-within-and-context","title":"11. \u2705 Complex AND/OR Within AND Context","text":"<p>Query: <pre><code>WHERE metadata.environment = 'prod'\n      AND (metadata.model = 'Table' OR metadata.model = 'Field' OR metadata.model = 'View')\n      AND metadata.year &gt; 2020\n</code></pre></p> <p>Expected Behavior: - Extracts: <code>{'Table', 'Field', 'View'}</code> (OR within AND context) - Routes to: Union of all three models' collections - Each collection applies the full predicate including <code>environment</code> and <code>year</code> filters</p> <p>Test: <code>test_extract_with_complex_or_and_and</code></p>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#12-or-with-unknown-model-value","title":"12. \u2705 OR with Unknown Model Value","text":"<p>Query: <pre><code>WHERE metadata.model = 'Table' OR metadata.model = 'UnknownModel'\n</code></pre></p> <p>Expected Behavior: - Extracts: <code>{'Table', 'UnknownModel'}</code> - Routes to: Collections for 'Table' (logs warning about 'UnknownModel') - Gracefully handles unknown discriminator values</p> <p>Test: <code>test_router_or_with_unknown_model_partial_routing</code></p>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#13-deduplication-of-overlapping-collections","title":"13. \u2705 Deduplication of Overlapping Collections","text":"<p>Query: <pre><code>WHERE metadata.model = 'Table' OR metadata.model = 'Field'\n</code></pre></p> <p>Setup: - Table \u2192 [coll_1, shared_coll] - Field \u2192 [coll_2, shared_coll]</p> <p>Expected Behavior: - Routes to: <code>[coll_1, coll_2, shared_coll]</code> (deduplicated) - Ensures <code>shared_coll</code> is only queried once</p> <p>Test: <code>test_router_deduplicates_collections_in_union</code></p>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#anti-patterns-and-why-theyre-avoided","title":"Anti-Patterns and Why They're Avoided","text":""},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#partial-routing-for-mixed-or-prevents-under-routing","title":"\u274c Partial Routing for Mixed OR (PREVENTS UNDER-ROUTING)","text":"<p>Some systems might try to route to only the discriminator values found: <pre><code>WHERE metadata.model = 'Table' OR metadata.has_sem = FALSE\n\u2192 Routes ONLY to 'Table' collections\n\u2192 PROBLEM: Misses records in other collections where has_sem = FALSE!\n</code></pre></p> <p>Why ChromaSQL Uses Fallback Instead: When any OR branch lacks the discriminator field, we fallback to all collections to ensure no under-routing. This is conservative but correct.</p>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#correct-behavior-conservative-fallback","title":"\u2705 Correct Behavior: Conservative Fallback","text":"<p>ChromaSQL's approach: <pre><code>WHERE metadata.model = 'Table' OR metadata.has_sem = FALSE\n\u2192 Routes to ALL collections (fallback)\n\u2192 RESULT: No under-routing, all matching records found\n</code></pre></p> <p>If you want efficient routing with mixed predicates, use AND: <pre><code>WHERE metadata.model = 'Table' AND metadata.has_sem = FALSE\n\u2192 Routes to 'Table' collections only (efficient)\n\u2192 RESULT: Only Table records with has_sem = FALSE\n</code></pre></p>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#implementation-details","title":"Implementation Details","text":""},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#how-union-extraction-works","title":"How Union Extraction Works","text":"<p>The <code>extract_metadata_values()</code> function in chromasql/analysis.py uses recursive traversal:</p> <ol> <li>BooleanPredicate (OR): Recursively collect values from all children</li> <li>BooleanPredicate (AND): Recursively collect values from all children (may be nested in OR)</li> <li>ComparisonPredicate (=): Extract single value if it matches discriminator field</li> <li>InPredicate: Extract all values if it matches discriminator field</li> <li>Other fields: Ignored (don't contribute to routing)</li> </ol>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#router-logic","title":"Router Logic","text":"<p>The <code>MetadataFieldRouter</code> in chromasql/adapters.py:</p> <ol> <li>Calls <code>extract_metadata_values()</code> to get discriminator values</li> <li>Maps each value to its collections via <code>query_config</code></li> <li>Takes union of all collection lists</li> <li>Deduplicates the final list</li> <li>Returns <code>None</code> if no values found (triggers fallback behavior)</li> </ol>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#test-coverage-summary","title":"Test Coverage Summary","text":"Category Tests Status Basic OR extraction 3 \u2705 Passing Nested OR/AND combinations 6 \u2705 Passing Fallback scenarios 2 \u2705 Passing Router integration 11 \u2705 Passing Total 22 \u2705 All Passing"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#usage-guidelines","title":"Usage Guidelines","text":""},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#do-use-or-for-union-queries","title":"\u2705 DO: Use OR for Union Queries","text":"<pre><code>-- Good: Efficiently queries only Table and Field collections\nSELECT * FROM sap_data\nWHERE metadata.model = 'Table' OR metadata.model = 'Field'\n</code></pre>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#do-combine-or-with-and-for-complex-filters","title":"\u2705 DO: Combine OR with AND for Complex Filters","text":"<pre><code>-- Good: Routes to Table + Field, applies additional filters\nSELECT * FROM sap_data\nWHERE (metadata.model = 'Table' AND metadata.system = 'S4')\n      OR (metadata.model = 'Field' AND metadata.required = TRUE)\n</code></pre>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#do-use-in-when-appropriate","title":"\u2705 DO: Use IN When Appropriate","text":"<pre><code>-- Good: Equivalent to OR, may be more readable\nSELECT * FROM sap_data\nWHERE metadata.model IN ('Table', 'Field', 'View')\n</code></pre>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#caution-or-without-discriminator","title":"\u26a0\ufe0f CAUTION: OR Without Discriminator","text":"<pre><code>-- Caution: Queries ALL collections (fallback mode)\nSELECT * FROM sap_data\nWHERE metadata.status = 'active' OR metadata.has_sem = TRUE\n</code></pre>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#caution-mixed-or-triggers-fallback","title":"\u26a0\ufe0f CAUTION: Mixed OR (Triggers Fallback)","text":"<pre><code>-- Caution: Queries ALL collections (conservative fallback)\nSELECT * FROM sap_data\nWHERE metadata.model = 'Table' OR metadata.has_sem = FALSE\n-- Result: Queries all 37 collections to avoid under-routing\n</code></pre> <p>Why fallback? The second OR branch could match records in any collection.</p> <p>To optimize, use AND instead: <pre><code>-- Better: Routes only to Table collections (efficient)\nSELECT * FROM sap_data\nWHERE metadata.model = 'Table' AND metadata.has_sem = FALSE\n-- Result: Only queries Table collections\n</code></pre></p>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#performance-implications","title":"Performance Implications","text":""},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#best-case-single-discriminator-value","title":"Best Case: Single Discriminator Value","text":"<p><pre><code>WHERE metadata.model = 'Table'\n</code></pre> - Routes to: ~2-3 collections (out of 37) - Fastest performance</p>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#good-case-union-of-few-values","title":"Good Case: Union of Few Values","text":"<p><pre><code>WHERE metadata.model IN ('Table', 'Field')\n</code></pre> - Routes to: ~4-6 collections (out of 37) - Still very efficient</p>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#acceptable-case-union-of-many-values","title":"Acceptable Case: Union of Many Values","text":"<p><pre><code>WHERE metadata.model = 'A' OR metadata.model = 'B' OR ... (10 models)\n</code></pre> - Routes to: ~20 collections (out of 37) - Better than querying all 37</p>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#worst-case-fallback-to-all","title":"Worst Case: Fallback to All","text":"<p><pre><code>WHERE metadata.status = 'active'\n</code></pre> - Routes to: All 37 collections - Use AND with discriminator to improve:   <pre><code>WHERE metadata.model = 'Table' AND metadata.status = 'active'\n</code></pre></p>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#future-enhancements","title":"Future Enhancements","text":"<p>Potential improvements (not currently implemented):</p> <ol> <li>Cost-Based Routing: If union size exceeds threshold, fallback to all collections</li> <li>Statistics-Driven Routing: Use collection size to decide routing strategy</li> <li>Partition Pruning: Route based on partition keys in addition to discriminator</li> <li>Query Rewriting: Optimize complex OR/AND combinations before routing</li> </ol>"},{"location":"using-csql-py/multi-collection/OR_ROUTING_EDGE_CASES/#references","title":"References","text":"<ul> <li>chromasql/analysis.py - Metadata value extraction</li> <li>chromasql/adapters.py - MetadataFieldRouter implementation</li> <li>chromasql/EXAMPLES.md - Multi-collection usage examples</li> </ul> <ul> <li> Need Help? Open a GitHub issue with the steps to reproduce and we\u2019ll help you debug it.</li> </ul>"},{"location":"using-csql-py/multi-collection/overview/","title":"Multi-Collection","text":"<p>Large deployments often shard data across multiple ChromaDB collections. The multi-collection module provides adapters and routing helpers that let you fan out a single ChromaSQL query across those shards.</p>"},{"location":"using-csql-py/multi-collection/overview/#core-concepts","title":"Core Concepts","text":"Component Description <code>CollectionRouter</code> Decides which collections should be queried based on the parsed AST. <code>AsyncCollectionProvider</code> Async interface for fetching collection handles. <code>execute_multi_collection</code> Orchestrates parse \u2192 plan \u2192 execute across collections and merges results."},{"location":"using-csql-py/multi-collection/overview/#metadata-based-routing","title":"Metadata-Based Routing","text":"<p>Use the built-in <code>MetadataFieldRouter</code> to route by discriminator values stored in metadata:</p> <pre><code>from chromasql.adapters import MetadataFieldRouter\nfrom chromasql.multi_collection import execute_multi_collection\nfrom idxr.query_lib.async_multi_collection_adapter import AsyncMultiCollectionAdapter\n\nrouter = MetadataFieldRouter(\n    query_config=config,\n    field_path=(\"model\",),\n    fallback_to_all=True,\n)\nadapter = AsyncMultiCollectionAdapter(async_client)\n\nresult = await execute_multi_collection(\n    query_str=\"SELECT id FROM demo WHERE metadata.model IN ('Table', 'Field');\",\n    router=router,\n    collection_provider=adapter,\n    embed_fn=my_embed_fn,\n)\n</code></pre> <p>The router reads the parsed query, extracts <code>metadata.model</code> values, maps them to collection names using the query config, and executes the plan in parallel.</p>"},{"location":"using-csql-py/multi-collection/overview/#custom-routers","title":"Custom Routers","text":"<p>Implement the <code>CollectionRouter</code> protocol for bespoke routing logic:</p> <pre><code>from chromasql.multi_collection import CollectionRouter\nfrom chromasql.analysis import extract_metadata_values\n\nclass TenantRouter(CollectionRouter):\n    def __init__(self, mapping):\n        self.mapping = mapping\n\n    def route(self, query):\n        tenant_ids = extract_metadata_values(query, field_path=(\"tenant_id\",))\n        if not tenant_ids:\n            return None  # query all collections\n        return [self.mapping[tenant] for tenant in tenant_ids if tenant in self.mapping]\n</code></pre>"},{"location":"using-csql-py/multi-collection/overview/#merging-strategy","title":"Merging Strategy","text":"<p><code>execute_multi_collection</code> collects rows from all collections, applies score thresholds, sorts by distance (or metadata order), respects LIMIT/OFFSET, and projects the requested columns.</p> <p>The merged <code>ExecutionResult</code> contains:</p> <ul> <li><code>rows</code>: projected rows after global ordering/pagination.</li> <li><code>raw</code>: summary payload with counts and metadata, useful for diagnostics.</li> </ul>"},{"location":"using-csql-py/multi-collection/overview/#error-handling","title":"Error Handling","text":"<ul> <li>Failed collections are logged and skipped; results from successful collections   are still returned.</li> <li>When <code>fallback_to_all</code> is disabled and no discriminator is present, the router   raises an error to avoid unexpected fan-out.</li> </ul> <p>Refer to <code>tests/chromasql/test_multi_collection.py</code> and <code>tests/chromasql/test_or_routing_integration.py</code> for exhaustive behavior.</p> <ul> <li> Need Help? Open a GitHub issue with the steps to reproduce and we\u2019ll help you debug it.</li> </ul>"}]}